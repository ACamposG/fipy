\minitoc[e]
    
    \section{How do I represent an equation in \FiPy{}?}
    
    As explained in Chapter~\ref{chap:Numerics}, the canonical
    governing equation that can be solved by \FiPy{} for the dependent
    \Class{CellVariable} $\phi$ is
        \begin{equation}                        
             \underbrace{
               \frac{\partial (\rho \phi)}{\partial t}
             }_{\text{transient}}
             =
             \underbrace{
               \vphantom{\frac{\partial (\rho \phi)}{\partial t}}
               \nabla \cdot \left( \vec{u} \phi \right)
             }_{\text{convection}}
             +
             \underbrace{
               \vphantom{\frac{\partial (\rho \phi)}{\partial t}}
               \left[ \nabla \cdot \left( \Gamma_i \nabla \right) \right]^n \phi
             }_{\text{diffusion}}
             +
             \underbrace{
               \vphantom{\frac{\partial (\rho \phi)}{\partial t}}
               S_{\phi}
             }_{\text{source}}
             \tag{\ref{eqn:num:gen}}
        \end{equation}
        A physical problem can involve many different coupled
        governing equations, one for each variable.  Numerous specific
        examples are presented in Part~\ref{part:Examples}, but let us
        examine this general expression term-by-term:
        
            \subsection{How do I represent a transient term 
            $\partial (\rho \phi) / \partial t$?}
            \hspace*{\fill}
            
            \begin{quote}
\begin{verbatim}
>>> TransientTerm(coeff = rho)
\end{verbatim}
            \end{quote}
          
            \begin{reSTadmonition}[Note]
                We have specified neither the variable $\phi$ nor the time
                step.  Both are handled when we actually solve the equation.
            \end{reSTadmonition}
            
            \subsection{How do I represent a convection term
            $\nabla \cdot \left( \vec{u} \phi \right)$?}
            \hspace*{\fill}
            
            \begin{quote}
\begin{verbatim}
>>> <Specific>ConvectionTerm(coeff = u, 
...                          diffusionTerm = diffTerm)
\end{verbatim}
            \end{quote}
            where \verb|<Specific>| can be any of \verb|CentralDiff|,
            \verb|Exponential|, \verb|Hybrid|, \verb|PowerLaw|,
            \verb|Upwind|, \verb|ExplicitUpwind|, or \verb|VanLeer|.
            The differences between these convection schemes are described
            in Section~\ref{sec:NumericalSchemes}. The velocity coefficient 
            \verb|u| must be a \Class{FaceVectorVariable}, or a 
            constant vector in the form of a Python list or tuple, 
            \emph{e.g.} \verb|(1,2)| for a vector in 2D.
            
            \begin{reSTadmonition}[Note]
                As discussed in Section~\ref{sec:NumericalSchemes}, the
                convection schemes need to calculate a P\'eclet number,
                and therefore need to know about any diffusion term
                used in the problem.  It is hoped that this dependency
                can be automated in the future.
            \end{reSTadmonition}
            
            \begin{reSTadmonition}[Warning]
                \Class{VanLeerConvectionTerm} not mentioned and no discussion of
                explicit forms.
            \end{reSTadmonition}
        
            \IndexPackage[How do I represent a diffusion term
            $\nabla \cdot \left( \Gamma_1 \nabla \phi \right)$?]
            \hspace*{\fill}
            
            Either
           \begin{quote}
\begin{verbatim}
>>> ImplicitDiffusionTerm(coeff = Gamma1)
\end{verbatim}
           \end{quote}
           or 
           \begin{quote}
\begin{verbatim}
>>> ExplicitDiffusionTerm(coeff = Gamma1)
\end{verbatim}
           \end{quote}
           \Class{ExplicitDiffusionTerm} is provided only for illustrative purposes.
           \Class{ImplicitDiffusionTerm} is almost always preferred. It is
           theoretically possible to create an explicit diffusion term with
           \begin{quote}
\begin{verbatim}
>>> (Gamma1 * phi.getFaceGrad()).getDivergence()
\end{verbatim}
           \end{quote}
           Unfortunately, in this form, any boundary conditions on $\phi$
           will not be accounted for.

            
           \subsection{How do I represent a term $\nabla^4 \phi$ or
            $\nabla \cdot \left( \Gamma_1 \nabla \left(
            \nabla\cdot\left( 
            \Gamma_2 \nabla \phi\right) \right) \right) $ such as for 
            Cahn-Hilliard?}
            \hspace*{\fill}
            
            \begin{quote}
\begin{verbatim}
>>> ImplicitDiffusionTerm(coeff = (Gamma1, Gamma2))
\end{verbatim}
            \end{quote}
            The number of elements supplied for \verb|coeff| determines the
            order of the term.

            \subsection{What if the term isn't one of those?}
            Any term that cannot be written in one of the previous
            forms is considered a source $S_{\phi}$. An explicit
            source is written in Python essentially as it appears in
            mathematical form, \emph{e.g.}, $3\kappa^2 + b \sin
            \theta$ would be written
            \begin{quote}
\begin{verbatim}
>>> 3 * kappa**2 + b * sin(theta)
\end{verbatim}
            \end{quote}
            
            \begin{reSTadmonition}[Note]
                Functions like \verb+sin()+ can be obtained from the
                \EpydocDottedName{fipy.tools.numerix} module.
                \begin{reSTadmonition}[Warning]
                    Generally, things will not work as expected if the
                    equivalent function is used from the \Numeric{}
                    library.
                \end{reSTadmonition}
            \end{reSTadmonition}
            
            If, however, the source depends on the variable that is being solved for,
            it can be advantageous to linearize the source and cast part of it as an
            implicit source term, \emph{e.g.}, $3\kappa^2 + \phi \sin \theta$
            might be written as
            \begin{quote}
\begin{verbatim}
>>> 3 * kappa**2 + ImplicitSourceTerm(coeff = sin(theta))
\end{verbatim}
            \end{quote}
            
            \begin{reSTadmonition}[Warning]
                There are subtleties in properly linearizing a source term
                which are examined in
                Example~\ref{examples:phase:simple:input}.
            \end{reSTadmonition}

            \subsection{How do I represent a \dots{} term that 
            \emph{doesn't} involve the dependent variable?}
            It is important to realize that, even though an expression may
            superficially resemble one of those shown above, if the
            dependent variable \emph{for that PDE} does not appear in the
            appropriate place, then that term should be treated as a source.

                \subsubsection{How do I represent a diffusive source?}
                    If the governing equation for $\phi$ is
                    \[
                        \frac{\partial \phi}{\partial t} 
                        = \nabla\cdot\left( D_1 \nabla \phi\right)
                        + \nabla\cdot\left( D_2 \nabla \xi\right)
                    \]
                    then the first term is a \Class{TransientTerm} and the second term 
                    is an \Class{ImplicitDiffusionTerm}, but the third term is 
                    simply an explicit source, which is written in Python as
                    \begin{quote}
\begin{verbatim}
>>> (D2 * xi.getFaceGrad()).getDivergence()
\end{verbatim}
                    \end{quote}
                    Higher order diffusive sources can be obtained by
                    simply nesting the calls to \verb+getFaceGrad()+
                    and \verb+getDivergence()+.
                    \begin{reSTadmonition}[Note]
                        We use \verb|getFaceGrad()|, rather than
                        \verb|getGrad()|, in order to obtain a
                        second-order spatial discretization of the
                        diffusion term in $\xi$, consistent with the
                        matrix that is formed by
                        \Class{ImplicitDiffusionTerm} for $\phi$.
                    \end{reSTadmonition}

                \subsubsection{How do I represent a convective source?}
                    The convection of an independent field $\xi$ as in
                    \[
                        \frac{\partial \phi}{\partial t} 
                        = \nabla\cdot
                        \left(
                            \vec{u} \xi
                        \right)
                    \]
                    can be rendered as
                    \begin{quote}
\begin{verbatim}
>>> (u * xi.getArithmeticFaceValue()).getDivergence()
\end{verbatim}
                    \end{quote}

                \subsubsection{How do I represent a transient source?}
                    The time-rate-of change of an independent variable
                    $\xi$, such as in
                    \[
                        \frac{\partial (\rho_1 \phi)}{\partial t}
                        = \frac{\partial (\rho_2 \xi)}{\partial t}
                    \]
                    does not have an abstract form in \FiPy{} and
                    should be discretized directly, in the manner of
                    Equation~\eqref{eqn:num:tra}, as
                    \begin{quote}
\begin{verbatim}
>>> TransientTerm(coeff = rho1) == rho2 * (xi - xi.getOld()) / timeStep
\end{verbatim}
                    \end{quote}
                    This technique is used in
                    Example~\ref{examples:phase:anisotropy:input}.
                    
        \subsection{What if my term involves the dependent variable, 
            but not where \FiPy{} puts it?}
            
            Frequently, viewing the term from a different perspective
            will allow it to be cast in one of the canonical forms.
            For example, the third term in
            \[
                \frac{\partial \phi}{\partial t} 
                = \nabla\cdot\left( D_1 \nabla \phi\right)
                + \nabla\cdot\left( D_2 \phi \nabla \xi\right)
            \]
            might be considered as the diffusion of the independent
            variable $\xi$ with a mobility $D_2\phi$ that is a
            function of the dependent variable $\phi$.  For \FiPy{}'s
            purposes, however, this term represents the convection of
            $\phi$, with a velocity $D_2\nabla\xi$, due to the
            counter-diffusion of $\xi$, so
            \begin{quote}
\begin{verbatim}
>>> diffTerm = ImplicitDiffusionTerm(coeff = D1)
>>> convTerm = <Specific>ConvectionTerm(coeff = D2 * xi.getFaceGrad(), 
...                                     diffusionTerm = diffTerm)
>>> eq = TransientTerm() == diffTerm + convTerm
\end{verbatim}

            \end{quote}

    \section{How do I export data?} The way to save your calculations
    depends on how you plan to make use of the data. If you want to
    save it for ``restart'' (so that you can continue or redirect a
    calculation from some intermediate stage), then you'll want to
    ``pickle'' the \Python{} data with the \Module{dump} module. This
    is illustrated in Examples~\ref{examples:phase:anisotropy:input},
    \ref{examples:phase:impingement:mesh40x1:input},
    \ref{examples:phase:impingement:mesh20x20:input}, and
    \ref{examples:levelSet:electroChem:inputWriteScriptHowTo}.
    
    On the other hand, pickled \FiPy{} data is of little use to
    anything besides \Python{} and \FiPy{}. If you want to import your
    calculations into another piece of software, whether to make
    publication-quality graphs or movies, or to perform some analysis,
    or as input to another stage of a multiscale model, then you can
    save your data as an \textsc{ascii} text file of
    tab-separated-values with a \Class{TSVViewer}. This is 
    illustrated in Example~\ref{examples:diffusion:circle}.
    
    \section{How do I save a plot image?} Some of the viewers have a
    button or other mechanism in the user interface for saving an
    image file. Also, you can supply an optional keyword
    \verb+filename+ when you tell the viewer to \verb+plot()+,
    \emph{e.g.}
    \begin{quote}
\begin{verbatim}
>>> viewer.plot(filename="myimage.ext")
\end{verbatim}
    \end{quote}
    which will save a file named \verb+myimage.ext+ in your current
    working directory. The type of image is determined by the file
    extension ``\verb+.ext+''. Different viewers have different
    capabilities: \Pygist{} accepts ``\verb+.eps+''
    (\href{http://en.wikipedia.org/wiki/Encapsulated_PostScript}{Encapsulated
    PostScript}) and ``\verb+.cgm+''
    (\href{http://xml.coverpages.org/cgm.html}{Computer Graphics
    Metafile}). \Matplotlib{} accepts ``\verb+.eps+'', ``\verb+.jpg+''
    (\href{http://www.jpeg.org/}{Joint Photographic Experts Group}),
    and ``\verb+.png+''
    (\href{http://www.w3.org/Graphics/PNG/}{Portable Network
    Graphics}). \MayaVi{} only accepts ``\verb+.png+''.

    \section{How do I make a movie?} \FiPy{} has no facilities for 
    making movies. You will need to save individual frames (see the 
    previous question) and then stitch them together into a movie, 
    using one of a variety of different free, shareware, or 
    commercial software packages.
    
    \section{Iterations, timesteps, and sweeps? Oh, my!} Any non-linear 
    solution of partial differential equations is an approximation. 
    These approximations benefit from repetetive solution to achieve 
    the best possible answer. In \FiPy{} (and in many similar PDE 
    solvers), there are three layers of repetition. 
    
    \begin{description}
    
        \item[iterations] This is the lowest layer of repetition,
        which you'll generally need to spend the least time thinking
        about. \FiPy{} solves PDEs by discretizing them into a set of
        linear equations in matrix form, as explained in
        Sections~\ref{section:discretization} and
        \ref{section:linear-equations}. It is not always practical, or
        even possible, to exactly solve these matrix equations on a
        computer. \FiPy{} thus employs ``iterative solvers'', which
        make successive approximations until the linear equations have
        been satisfactorily solved. \FiPy{} chooses a default number
        of iterations and solution tolerance, which you will not
        generally need to change. If you do wish to change these
        defaults, you'll need to create a new \Class{Solver} object
        with the desired number of iterations and solution tolerance,
        \emph{e.g.}
        \begin{quote}
\begin{verbatim}
>>> mySolver = LinearPCGSolver(iterations=1234, tolerance=5e-6) 
    : 
    :
>>> eq.solve(..., solver=mySolver, ...)
\end{verbatim}
    	\end{quote}
        \begin{reSTadmonition}[Note]
        The older \Class{Solver} \verb+steps=+ keyword is now
        deprecated in favor of \verb+iterations=+ to make the role
        clearer.
        \end{reSTadmonition}
        Solver iterations are modified in
        Examples~\ref{examples:cahnHilliard:inputTanh1D},
        \ref{examples:flow:stokesCavity}, and
        \ref{chap:Update0.1to1.0}.
        
        \item[sweeps] This middle layer of repetition is importrant
        when a PDE is non-linear (\emph{e.g.}, a diffusivity that
        depends on concentration) or when multiple PDEs are coupled
        (\emph{e.g.}, if solute diffusivity depends on temperature and
        thermal conductivity depends on concentration). Even if the
        \Class{Solver} solves the \emph{linear} approximation of the
        PDE to absolute perfection by performing an infinite number of
        \emph{iterations}, the solution may still not be a very good
        representation of the actual \emph{non-linear} PDE. If we
        resolve the same equation \emph{at the same point in elapsed
        time}, but use the result of the previous solution instead of 
        the previous timestep, then we can get a refined solution to 
        the \emph{non-linear} PDE. This process is known as 
        ``sweeping''. To sweep in \FiPy{}, we need to do two things 
        differently,
        
        \item[timesteps] This is the outermost layer of repetition, 
        and is of most interest to the user.
    
    \end{description}
    
    We can (and often do) combine all three layers of repetition:
    \begin{quote}
\begin{verbatim}
>>> myVar = CellVariable(..., hasOld=1)
: 
:
>>> mySolver = LinearPCGSolver(iterations=1234, tolerance=5e-6) 
: 
:
>>> while elapsedTime < totalElapsedTime:
...     myVar.updateOld()
...     while residual > minResidual:
...         res = eq.sweep(...

>>> eq.solve(..., solver=mySolver, ...)
\end{verbatim}

    \section{Why the distinction between \Class{CellVariable} and
    \Class{FaceVariable} coefficients?}  \FiPy{} solves field
    variables on the \Class{Cell} centers.  Transient and source terms
    describe the change in the value of a field at the \Class{Cell}
    center, and so they take a \Class{CellVariable} coefficient.
    Diffusion and convection terms involve fluxes \emph{between}
    \Class{Cell} centers, and are calculated on the \Class{Face}
    between two \Class{Cell}s, and so they take a \Class{FaceVariable}
    or \Class{VectorFaceVariable} coefficient.
    
    
    \begin{reSTadmonition}[Note]
        If you supply a \Class{CellVariable} \verb+var+ when a
        \Class{FaceVariable} is expected, \FiPy{} will automatically
        substitute \verb+var.getArithmeticFaceValue()+.  This can have
        undesirable consequences, however. For one thing, the 
        arithmetic face average of a non-linear function is not the 
        same as the same non-linear function of the average argument, 
        \emph{e.g.}, for $f(x) = x^2$,
        \[ f(\frac{1+2}{2}) = \frac{9}{4} \neq 
        \frac{f(1) + f(2)}{2} = \frac{5}{2} \]
        This distinction is not generally important for smoothly
        varying functions, but can dramatically affect the solution
        when sharp changes are present.  Also, for many problems, such
        as a conserved concentration field that cannot be allowed to
        drop below zero, a harmonic average is more appropriate than
        an arithmetic average.
        
        If you experience problems (unstable or wrong results, or 
        excessively small timesteps), you may need to explicitly supply the 
        desired \Class{FaceVariable} rather than letting \FiPy{} 
        assume one.
    \end{reSTadmonition}
        
    \section{What does this error message mean?}\hspace*{\fill}
    
        \begin{itemize}
            
            \item ``\texttt{ValueError: frames are not aligned}''
            
            This error most likely means that you have provided a
            \Class{CellVariable} when \FiPy{} was expecting a
            \Class{FaceVariable} (or vice versa).

            \item ``\texttt{MA.MA.MAError: Cannot automatically
            convert masked array to Numeric because data is masked in one or
            more locations.}''
            
            This not-so-helpful error message could mean a number of things,
            but the most likely explanation is that the solution has become
            unstable and is diverging to $\pm\infty$.  This can be caused by
            taking too large a timestep or by using explicit terms instead of
            implicit ones.
            
            \item ``\texttt{repairing catalog by removing key}''
            
            This message (not really an error, but may cause test 
            failures) can result when using the \SciPy{} \weave{} 
            package via the \verb+--inline+ flag. It is due to a bug
            in \SciPy{} that has been patched in their source 
            repository: \url{http://www.scipy.org/mailinglists/mailman?fn=scipy-dev/2005-June/003010.html}.
            
            \item ``\texttt{numerix Numeric 23.6}''
            
            This is neither an error nor a warning. It's just sloppy 
            message left in \SciPy{}:
            \url{http://thread.gmane.org/gmane.comp.python.scientific.user/4349}.
            
        \end{itemize}

    \section{What if my question isn't answered here?}  
        
        Please post your question to the
        \href{http://www.ctcms.nist.gov/fipy/mail.html}{mailing list}
        \cite{FiPyMailingList} or
        \href{http://sourceforge.net/tracker/?group_id=118428}{file a
        Tracker request} \cite{FiPyBugTracker}.
