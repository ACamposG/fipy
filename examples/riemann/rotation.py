#!/usr/bin/env python

## 
 # ###################################################################
 #  FiPy - Python-based finite volume PDE solver
 # 
 #  FILE: "rotation.py"
 #
 #  Author: Jonathan Guyer <guyer@nist.gov>
 #  Author: Daniel Wheeler <daniel.wheeler@nist.gov>
 #  Author: James Warren   <jwarren@nist.gov>
 #    mail: NIST
 #     www: http://www.ctcms.nist.gov/fipy/
 #  
 # ========================================================================
 # This software was developed at the National Institute of Standards
 # and Technology by employees of the Federal Government in the course
 # of their official duties.  Pursuant to title 17 Section 105 of the
 # United States Code this software is not subject to copyright
 # protection and is in the public domain.  FiPy is an experimental
 # system.  NIST assumes no responsibility whatsoever for its use by
 # other parties, and makes no guarantees, expressed or implied, about
 # its quality, reliability, or any other characteristic.  We would
 # appreciate acknowledgement if the software is used.
 # 
 # This software can be redistributed and/or modified freely
 # provided that any derivative works bear some notice that they are
 # derived from it, and any modified versions bear some notice that
 # they have been modified.
 # ========================================================================
 #  
 # ###################################################################
 ##

r"""

This example demonstrates the use of the
:class:`fipy.terms.roeConvectionTerm.RoeConvectionTerm` for a single
equation. The example is taken from the Clawpack_ code and the results
are compared with data generated by Clawpack_. The example solves
solid-body rotation for circular and square regions using the
advection equation given by,

.. math::
   
   \frac{\partial \phi}{\partial t} + \nabla \cdot \left( \vec{u} \phi \right) = 0

with

.. math::

   \vec{u} = \left(2 y, -2 x \right)

>>> from fipy import Grid2D, CellVariable, FaceVariable, TransientTerm, Viewer
>>> from fipy import numerix, RoeConvectionTerm, FirstOrderRoeConvectionTerm

>>> N = 80
>>> L = 2.
>>> origin = [[-1], [-1]]

>>> mesh = Grid2D(nx=N, ny=N, Lx=L, Ly=L) + origin

>>> var = CellVariable(mesh=mesh, hasOld=True)

Set the initial conditions (see image below).

>>> def initialize(v):
...     v[:] = 0.
...     ## square
...     v[(0.1 < mesh.x) & (mesh.x < 0.6) & (-0.25 < mesh.y) & (mesh.y < 0.25)] = 1.
...     ##circle
...     r = numerix.sqrt((mesh.x + 0.45)**2 + mesh.y**2)
...     v[r < 0.35] = (1 - r / 0.35)[r < 0.35]

>>> initialize(var)

Set the velocity field in the manner used in Clawpack_ for comparison purposes.

>>> vel = FaceVariable(mesh=mesh, rank=1)
>>> def psi(x, y):
...     return x**2 + y**2
>>> X, Y = mesh.faceCenters
>>> vel[0] = (psi(X, Y + mesh.dy / 2) - psi(X, Y - mesh.dy / 2)) / mesh.dy
>>> vel[1] = -(psi(X + mesh.dx / 2, Y) - psi(X - mesh.dx / 2., Y)) / mesh.dx

Initially use only a first order
(:class:`fipy.terms.firstOrderRoeConvectionTerm.FirstOrderRoeConvectionTerm`)
scheme to compare with Clawpack_.

>>> eqn = TransientTerm() + FirstOrderRoeConvectionTerm(vel)

>>> if __name__ == '__main__':
...     viewer = Viewer(var)
...     viewer.plot()
...     raw_input("Solid-body rotation initial conditions. Press <return> to proceed...")

.. image:: rotationInitialConditions.*
   :width: 90%
   :align: center
   :alt: Initial conditions for solid-body rotation.

The time step is fixed to facilitate comparison with Clawpack_.

>>> dt = 0.0009

Do 50 time steps.

>>> for step in range(50):
...     var.updateOld()
...     eqn.solve(var, dt=dt)
...     if step % 10 == 0 and __name__ == '__main__':
...         viewer.plot()

Compare the FiPy and Clawpack_ first order results. 

>>> import os 
>>> filepath = os.path.splitext(__file__)[0] + 'ClawpackFirstOrder.gz'
>>> print var.allclose(numerix.loadtxt(filepath, skiprows=9))
True

>>> if __name__ == "__main__":
...     raw_input("First order scheme. Press <return> to proceed...")

Now, use a second order convection scheme
(:class:`fipy.terms.RoeConvectionTerm.RoeConvectionTerm`)
to compare with Clawpack_.

Reinitialize the field.

>>> initialize(var)
>>> eqn = TransientTerm() + RoeConvectionTerm(vel)

Do 50 time steps.

>>> for step in range(50):
...     var.updateOld()
...     eqn.solve(var, dt=dt)
...     if step % 10 == 0 and __name__ == '__main__':
...         viewer.plot()

Compare the FiPy and Clawpack_ second order results.

>>> import os 
>>> filepath = os.path.splitext(__file__)[0] + 'ClawpackSecondOrder.gz'
>>> print var.allclose(numerix.loadtxt(filepath, skiprows=9))
True

>>> if __name__ == "__main__":
...     raw_input("Second order scheme. Press <return> to proceed...")

Evolve the equation for one complete revolution.

>>> initialize(var)
>>> elapsedTime = 0.0
>>> step = 0

Choose a time step that satisfies the CFL requirement.

>>> maxvel = 2. * numerix.sqrt(2.)
>>> dt = numerix.pi / N / 16.
>>> cfl_dt = mesh.dx / maxvel / numerix.sqrt(2)
>>> print dt < cfl_dt
True

>>> if __name__ == "__main__":
...     while elapsedTime < numerix.pi:
...         var.updateOld()
...         eqn.solve(var, dt=dt)
...         if step % 10 == 0:
...             viewer.plot()
...         step += 1
...         elapsedTime += dt

Display the field after one revolution.

>>> if __name__ == "__main__":
...     viewer.plot()
...     raw_input("One revolution. Press <return> to proceed...")

.. image:: rotation.*
   :width: 90%
   :align: center
   :alt: Conditions after one complete revolution.

.. _Clawpack: http://www.nist.gov/cgi-bin/exit_nist.cgi?url=http://depts.washington.edu/clawpack/

"""

__docformat__ = 'restructuredtext'

if __name__ == '__main__':
    import fipy.tests.doctestPlus
    exec(fipy.tests.doctestPlus._getScript())
