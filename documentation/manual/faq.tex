\minitoc[e]
    
    \section{How do I represent an equation in \FiPy{}?}
    
    As explained in Chapter~\ref{chap:Numerics}, the canonical
    governing equation that can be solved by \FiPy{} for the dependent
    \Class{CellVariable} $\phi$ is
        \begin{equation}                        
             \underbrace{
               \frac{\partial (\rho \phi)}{\partial t}
             }_{\text{transient}}
             =
             \underbrace{
               \vphantom{\frac{\partial (\rho \phi)}{\partial t}}
               \nabla \cdot \left( \vec{u} \phi \right)
             }_{\text{convection}}
             +
             \underbrace{
               \vphantom{\frac{\partial (\rho \phi)}{\partial t}}
               \left[ \nabla \cdot \left( \Gamma_i \nabla \right) \right]^n \phi
             }_{\text{diffusion}}
             +
             \underbrace{
               \vphantom{\frac{\partial (\rho \phi)}{\partial t}}
               S_{\phi}
             }_{\text{source}}
             \tag{\ref{eqn:num:gen}}
        \end{equation}
        A physical problem can involve many different coupled
        governing equations, one for each variable.  Numerous specific
        examples are presented in Part~\ref{part:Examples}, but let us
        examine this general expression term-by-term:
        
            \subsection{How do I represent a transient term 
            $\partial (\rho \phi) / \partial t$?}
            \hspace*{\fill}
            
            \begin{quote}
\begin{verbatim}
>>> TransientTerm(coeff = rho)
\end{verbatim}
            \end{quote}
          
            \begin{reSTadmonition}[Note]
                We have specified neither the variable $\phi$ nor the time
                step.  Both are handled when we actually solve the equation.
            \end{reSTadmonition}
            
            \subsection{How do I represent a convection term
            $\nabla \cdot \left( \vec{u} \phi \right)$?}
            \hspace*{\fill}
            
            \begin{quote}
\begin{verbatim}
>>> <Specific>ConvectionTerm(coeff = u, 
...                          diffusionTerm = diffTerm)
\end{verbatim}
            \end{quote}
            where \verb|<Specific>| can be any of \verb|CentralDiff|,
            \verb|Exponential|, \verb|Hybrid|, \verb|PowerLaw|,
            \verb|Upwind|, \verb|ExplicitUpwind|, or \verb|VanLeer|.
            The differences between these convection schemes are described
            in Section~\ref{sec:NumericalSchemes}. The velocity coefficient 
            \verb|u| must be a \Class{FaceVectorVariable}, or a 
            constant vector in the form of a Python list or tuple, 
            \emph{e.g.} \verb|(1,2)| for a vector in 2D.
            
            \begin{reSTadmonition}[Note]
                As discussed in Section~\ref{sec:NumericalSchemes}, the
                convection schemes need to calculate a P\'eclet number,
                and therefore need to know about any diffusion term
                used in the problem.  It is hoped that this dependency
                can be automated in the future.
            \end{reSTadmonition}
            
            \begin{reSTadmonition}[Warning]
                \Class{VanLeerConvectionTerm} not mentioned and no discussion of
                explicit forms.
            \end{reSTadmonition}
        
            \subsection{How do I represent a diffusion term
            $\nabla \cdot \left( \Gamma_1 \nabla \phi \right)$?}
            \hspace*{\fill}
            
            Either
           \begin{quote}
\begin{verbatim}
>>> ImplicitDiffusionTerm(coeff = Gamma1)
\end{verbatim}
           \end{quote}
           or 
           \begin{quote}
\begin{verbatim}
>>> ExplicitDiffusionTerm(coeff = Gamma1)
\end{verbatim}
           \end{quote}
           \Class{ExplicitDiffusionTerm} is provided only for illustrative purposes.
           \Class{ImplicitDiffusionTerm} is almost always preferred. It is
           theoretically possible to create an explicit diffusion term with
           \begin{quote}
\begin{verbatim}
>>> (Gamma1 * phi.getFaceGrad()).getDivergence()
\end{verbatim}
           \end{quote}
           Unfortunately, in this form, any boundary conditions on $\phi$
           will not be accounted for.

            
           \subsection{How do I represent a term $\nabla^4 \phi$ or
            $\nabla \cdot \left( \Gamma_1 \nabla \left(
            \nabla\cdot\left( 
            \Gamma_2 \nabla \phi\right) \right) \right) $ such as for 
            Cahn-Hilliard?}
            \hspace*{\fill}
            
            \begin{quote}
\begin{verbatim}
>>> ImplicitDiffusionTerm(coeff = (Gamma1, Gamma2))
\end{verbatim}
            \end{quote}
            The number of elements supplied for \verb|coeff| determines the
            order of the term.

            \subsection{What if the term isn't one of those?}
            Any term that cannot be written in one of the previous
            forms is considered a source $S_{\phi}$. An explicit
            source is written in Python essentially as it appears in
            mathematical form, \emph{e.g.}, $3\kappa^2 + b \sin
            \theta$ would be written
            \begin{quote}
\begin{verbatim}
>>> 3 * kappa**2 + b * sin(theta)
\end{verbatim}
            \end{quote}
            
            \begin{reSTadmonition}[Note]
                Functions like \verb+sin()+ can be obtained from the
                \EpydocDottedName{fipy.tools.numerix} module.
                \begin{reSTadmonition}[Warning]
                    Generally, things will not work as expected if the
                    equivalent function is used from the \Numeric{}
                    library.
                \end{reSTadmonition}
            \end{reSTadmonition}
            
            If, however, the source depends on the variable that is being solved for,
            it can be advantageous to linearize the source and cast part of it as an
            implicit source term, \emph{e.g.}, $3\kappa^2 + \phi \sin \theta$
            might be written as
            \begin{quote}
\begin{verbatim}
>>> 3 * kappa**2 + ImplicitSourceTerm(coeff = sin(theta))
\end{verbatim}
            \end{quote}
            
            \begin{reSTadmonition}[Warning]
                There are subtleties in properly linearizing a source term
                which are examined in
                Example~\ref{examples:phase:simple:input}.
            \end{reSTadmonition}

            \subsection{How do I represent a \dots{} term that 
            \emph{doesn't} involve the dependent variable?}
            It is important to realize that, even though an expression may
            superficially resemble one of those shown above, if the
            dependent variable \emph{for that PDE} does not appear in the
            appropriate place, then that term should be treated as a source.

                \subsubsection{How do I represent a diffusive source?}
                    If the governing equation for $\phi$ is
                    \[
                        \frac{\partial \phi}{\partial t} 
                        = \nabla\cdot\left( D_1 \nabla \phi\right)
                        + \nabla\cdot\left( D_2 \nabla \xi\right)
                    \]
                    then the first term is a \Class{TransientTerm} and the second term 
                    is an \Class{ImplicitDiffusionTerm}, but the third term is 
                    simply an explicit source, which is written in Python as
                    \begin{quote}
\begin{verbatim}
>>> (D2 * xi.getFaceGrad()).getDivergence()
\end{verbatim}
                    \end{quote}
                    Higher order diffusive sources can be obtained by
                    simply nesting the calls to \verb+getFaceGrad()+
                    and \verb+getDivergence()+.
                    \begin{reSTadmonition}[Note]
                        We use \verb|getFaceGrad()|, rather than
                        \verb|getGrad()|, in order to obtain a
                        second-order spatial discretization of the
                        diffusion term in $\xi$, consistent with the
                        matrix that is formed by
                        \Class{ImplicitDiffusionTerm} for $\phi$.
                    \end{reSTadmonition}

                \subsubsection{How do I represent a convective source?}
                    The convection of an independent field $\xi$ as in
                    \[
                        \frac{\partial \phi}{\partial t} 
                        = \nabla\cdot
                        \left(
                            \vec{u} \xi
                        \right)
                    \]
                    can be rendered as
                    \begin{quote}
\begin{verbatim}
>>> (u * xi.getArithmeticFaceValue()).getDivergence()
\end{verbatim}
                    \end{quote}
                    when $\vec{u}$ is a \Class{VectorFaceVariable} 
                    (preferred) or as
                    \begin{quote}
\begin{verbatim}
>>> (u * xi).getDivergence()
\end{verbatim}
                    \end{quote}
                    if $\vec{u} is a \Class{VectorCellVariable}.


                \subsubsection{How do I represent a transient source?}
                    The time-rate-of change of an independent variable
                    $\xi$, such as in
                    \[
                        \frac{\partial (\rho_1 \phi)}{\partial t}
                        = \frac{\partial (\rho_2 \xi)}{\partial t}
                    \]
                    does not have an abstract form in \FiPy{} and
                    should be discretized directly, in the manner of
                    Equation~\eqref{eqn:num:tra}, as
                    \begin{quote}
\begin{verbatim}
>>> TransientTerm(coeff = rho1) == rho2 * (xi - xi.getOld()) / timeStep
\end{verbatim}
                    \end{quote}
                    This technique is used in
                    Example~\ref{examples:phase:anisotropy:input}.
                    
        \subsection{What if my term involves the dependent variable, 
            but not where \FiPy{} puts it?}
            
            Frequently, viewing the term from a different perspective
            will allow it to be cast in one of the canonical forms.
            For example, the third term in
            \[
                \frac{\partial \phi}{\partial t} 
                = \nabla\cdot\left( D_1 \nabla \phi\right)
                + \nabla\cdot\left( D_2 \phi \nabla \xi\right)
            \]
            might be considered as the diffusion of the independent
            variable $\xi$ with a mobility $D_2\phi$ that is a
            function of the dependent variable $\phi$.  For \FiPy{}'s
            purposes, however, this term represents the convection of
            $\phi$, with a velocity $D_2\nabla\xi$, due to the
            counter-diffusion of $\xi$, so
            \begin{quote}
\begin{verbatim}
>>> diffTerm = ImplicitDiffusionTerm(coeff = D1)
>>> convTerm = <Specific>ConvectionTerm(coeff = D2 * xi.getFaceGrad(), 
...                                     diffusionTerm = diffTerm)
>>> eq = TransientTerm() == diffTerm + convTerm
\end{verbatim}
            \end{quote}

        \subsection{What if the coefficient of a term depends on 
            the variable that I'm solving for?}
            
            A non-linear coefficient, such as the diffusion 
            coefficient in \( 
            \nabla\cdot[\Gamma_1(\phi) \nabla \phi] = 
            \nabla\cdot[\Gamma_0 \phi (1 - \phi) \nabla\phi] \) is 
            not a problem for \FiPy. Simply write it as it appears:
            \begin{quote}
\begin{verbatim}
>>> diffTerm = ImplicitDiffusionTerm(coeff = Gamma0 * phi * (1 - phi))
\end{verbatim}
            \end{quote}
            \begin{reSTadmonition}[Note]
            Due to the nonlinearity of the coefficient, it will
            probably be necessary to ``sweep'' the solution to
            convergence as discussed in
            FAQ~\ref{FAQ-IterationsTimestepsSweeps}.
            \end{reSTadmonition}


    \section{How do I export data?} The way to save your calculations
    depends on how you plan to make use of the data. If you want to
    save it for ``restart'' (so that you can continue or redirect a
    calculation from some intermediate stage), then you'll want to
    ``pickle'' the \Python{} data with the \Module{dump} module. This
    is illustrated in Examples~\ref{examples:phase:anisotropy:input},
    \ref{examples:phase:impingement:mesh40x1:input},
    \ref{examples:phase:impingement:mesh20x20:input}, and
    \ref{examples:levelSet:electroChem:inputWriteScriptHowTo}.
    
    On the other hand, pickled \FiPy{} data is of little use to
    anything besides \Python{} and \FiPy{}. If you want to import your
    calculations into another piece of software, whether to make
    publication-quality graphs or movies, or to perform some analysis,
    or as input to another stage of a multiscale model, then you can
    save your data as an \textsc{ascii} text file of
    tab-separated-values with a \Class{TSVViewer}. This is 
    illustrated in Example~\ref{examples:diffusion:circle}.
    
    \section{How do I save a plot image?} Some of the viewers have a
    button or other mechanism in the user interface for saving an
    image file. Also, you can supply an optional keyword
    \verb+filename+ when you tell the viewer to \verb+plot()+,
    \emph{e.g.}
    \begin{quote}
\begin{verbatim}
>>> viewer.plot(filename="myimage.ext")
\end{verbatim}
    \end{quote}
    which will save a file named \verb+myimage.ext+ in your current
    working directory. The type of image is determined by the file
    extension ``\verb+.ext+''. Different viewers have different
    capabilities: \Pygist{} accepts ``\verb+.eps+''
    (\href{http://en.wikipedia.org/wiki/Encapsulated_PostScript}{Encapsulated
    PostScript}) and ``\verb+.cgm+''
    (\href{http://xml.coverpages.org/cgm.html}{Computer Graphics
    Metafile}). \Matplotlib{} accepts ``\verb+.eps+'', ``\verb+.jpg+''
    (\href{http://www.jpeg.org/}{Joint Photographic Experts Group}),
    and ``\verb+.png+''
    (\href{http://www.w3.org/Graphics/PNG/}{Portable Network
    Graphics}). \MayaVi{} only accepts ``\verb+.png+''.

    \section{How do I make a movie?} \FiPy{} has no facilities for 
    making movies. You will need to save individual frames (see the 
    previous question) and then stitch them together into a movie, 
    using one of a variety of different free, shareware, or 
    commercial software packages.
    
    \section{Iterations, timesteps, and sweeps? Oh, my!} 
    \label{FAQ-IterationsTimestepsSweeps}
    Any non-linear solution of partial differential equations is an
    approximation. These approximations benefit from repetetive
    solution to achieve the best possible answer. In \FiPy{} (and in
    many similar PDE solvers), there are three layers of repetition.
    
    \begin{description}
    
        \item[iterations] This is the lowest layer of repetition,
        which you'll generally need to spend the least time thinking
        about. \FiPy{} solves PDEs by discretizing them into a set of
        linear equations in matrix form, as explained in
        Sections~\ref{section:discretization} and
        \ref{section:linear-equations}. It is not always practical, or
        even possible, to exactly solve these matrix equations on a
        computer. \FiPy{} thus employs ``iterative solvers'', which
        make successive approximations until the linear equations have
        been satisfactorily solved. \FiPy{} chooses a default number
        of iterations and solution tolerance, which you will not
        generally need to change. If you do wish to change these
        defaults, you'll need to create a new \Class{Solver} object
        with the desired number of iterations and solution tolerance,
        \emph{e.g.}
        \begin{quote}
\begin{verbatim}
>>> mySolver = LinearPCGSolver(iterations=1234, tolerance=5e-6) 
    : 
    :
>>> eq.solve(..., solver=mySolver, ...)
\end{verbatim}
    	\end{quote}
        \begin{reSTadmonition}[Note]
        The older \Class{Solver} \verb+steps=+ keyword is now
        deprecated in favor of \verb+iterations=+ to make the role
        clearer.
        \end{reSTadmonition}
        Solver iterations are changed from their defaults in
        Examples~\ref{examples:cahnHilliard:inputTanh1D},
        \ref{examples:flow:stokesCavity}, and
        \ref{chap:Update0.1to1.0}.
        
        \item[sweeps] This middle layer of repetition is important
        when a PDE is non-linear (\emph{e.g.}, a diffusivity that
        depends on concentration) or when multiple PDEs are coupled
        (\emph{e.g.}, if solute diffusivity depends on temperature and
        thermal conductivity depends on concentration). Even if the
        \Class{Solver} solves the \emph{linear} approximation of the
        PDE to absolute perfection by performing an infinite number of
        iterations, the solution may still not be a very good
        representation of the actual \emph{non-linear} PDE. If we
        resolve the same equation \emph{at the same point in elapsed
        time}, but use the result of the previous solution instead of 
        the previous timestep, then we can get a refined solution to 
        the \emph{non-linear} PDE in a process known as ``sweeping.'' 
        \begin{reSTadmonition}[Note]
        Despite references to the ``previous timestep,'' sweeping is 
        not limited to time-evolving problems. Nonlinear sets of 
        quasi-static or steady-state PDEs can require sweeping, too.
        \end{reSTadmonition}
        We need to distinguish between the value of the variable at
        the last timestep and the value of the variable at the last
        sweep (the last cycle where we tried to solve the
        \emph{current} timestep). This is done by first modifying the
        way the variable is created:
        \begin{quote}
\begin{verbatim}
>>> myVar = CellVariable(..., hasOld=1)
\end{verbatim}
        \end{quote}
        and then by explicitly moving the current value of the 
        variable into the ``old'' value only when we want to:
        \begin{quote}
\begin{verbatim}
>>> myVar.updateOld()
\end{verbatim}
        \end{quote}
        Finally, we will need to repeatedly solve the equation until 
        it gives a stable result. To clearly distinguish that a 
        single cycle will not truly ``solve'' the equation, we invoke 
        a different method ``\verb+sweep()+''\IndexFunction{sweep}:
        \begin{quote}
\begin{verbatim}
>>> for sweep in range(sweeps):
...     eq.sweep(var=myVar, ...)
\end{verbatim}
        \end{quote}
        Even better than sweeping a fixed number of cycles is to do it 
        until the non-linear PDE has been solved satisfactorily:
        \begin{quote}
\begin{verbatim}
>>> while residual > desiredResidual:
...     residual = eq.sweep(var=myVar, ...)
\end{verbatim}
        \end{quote}
        Sweeps are used to achieve better solutions in
        Examples~\ref{examples:diffusion:mesh1D}, 
        \ref{examples:phase:simple:input}, 
        \ref{examples:phase:binary}, and \ref{examples:flow:stokesCavity}.

        \item[timesteps] This outermost layer of repetition is of most
        practical interest to the user. Understanding the time
        evolution of a problem is frequently the goal of studying a
        particular set of PDEs. Moreover, even when only an
        equilibrium or steady-state solution is desired, it may not be
        possible to simply solve that directly, due to non-linear
        coupling between equations or to boundary conditions or
        initial conditions. Some types of PDEs have fundamental 
        limits to how large a timestep they can take before they 
        become either unstable or inaccurate.
        \begin{reSTadmonition}[Note]
        Stability and accuracy are distinctly different. An unstable 
        solution is often said to ``blow up'', with radically 
        different values from point to point, often diverging to 
        infinity. An inaccurate solution may look perfectly 
        reasonable, but will disagree significantly from an 
        analytical solution or from a numerical solution obtained by 
        taking either smaller or larger timesteps. 
        \end{reSTadmonition}
        For all of these reasons, you will frequently need to advance
        a problem in time and to choose an appropriate interval
        between solutions. This can be simple:
        \begin{quote}
\begin{verbatim}
>>> timeStep = 1.234e-5
>>> for step in range(steps):
...     eq.solve(var=myVar, dt=timeStep, ...)
\end{verbatim}
        \end{quote}
        or more elaborate:
        \begin{quote}
\begin{verbatim}
>>> timeStep = 1.234e-5
>>> elapsedTime = 0
>>> while elapsedTime < totalElapsedTime:
...     eq.solve(var=myVar, dt=timeStep, ...)
...     elapsedTime += timeStep
...     timeStep = SomeFunctionOfVariablesAndTime(myVar1, myVar2, elapedTime)
\end{verbatim}
        \end{quote}

        A majority of the examples in this manual illustrate time
        evolving behavior. Notably, boundary conditions are made a
        function of elapsed time in
        Example~\ref{examples:diffusion:mesh1D}. The timestep is
        chosen based on the expected interfacial velocity in
        Example~\ref{examples:phase:simple:input}. The timestep is
        gradually increased as the kinetics slow down in
        Example~\ref{examples:cahnHilliard:inputTanh1D}.
    
    \end{description}
    
    Finally, we can (and often do) combine all three layers of repetition:
    \begin{quote}
\begin{verbatim}
>>> myVar = CellVariable(..., hasOld=1)
    : 
    :
>>> mySolver = LinearPCGSolver(iterations=1234, tolerance=5e-6) 
    : 
    :
>>> while elapsedTime < totalElapsedTime:
...     myVar.updateOld()
...     while residual > desiredResidual:
...         residual = eq.sweep(var=myVar, dt=timeStep, ...)
...     elapsedTime += timeStep
\end{verbatim}
    \end{quote}

    \section{Why the distinction between \Class{CellVariable} and
    \Class{FaceVariable} coefficients?}  \FiPy{} solves field
    variables on the \Class{Cell} centers.  Transient and source terms
    describe the change in the value of a field at the \Class{Cell}
    center, and so they take a \Class{CellVariable} coefficient.
    Diffusion and convection terms involve fluxes \emph{between}
    \Class{Cell} centers, and are calculated on the \Class{Face}
    between two \Class{Cell}s, and so they take a \Class{FaceVariable}
    or \Class{VectorFaceVariable} coefficient.
    
    
    \begin{reSTadmonition}[Note]
        If you supply a \Class{CellVariable} \verb+var+ when a
        \Class{FaceVariable} is expected, \FiPy{} will automatically
        substitute \verb+var.getArithmeticFaceValue()+.  This can have
        undesirable consequences, however. For one thing, the 
        arithmetic face average of a non-linear function is not the 
        same as the same non-linear function of the average argument, 
        \emph{e.g.}, for $f(x) = x^2$,
        \[ f(\frac{1+2}{2}) = \frac{9}{4} \neq 
        \frac{f(1) + f(2)}{2} = \frac{5}{2} \]
        This distinction is not generally important for smoothly
        varying functions, but can dramatically affect the solution
        when sharp changes are present.  Also, for many problems, such
        as a conserved concentration field that cannot be allowed to
        drop below zero, a harmonic average is more appropriate than
        an arithmetic average.
        
        If you experience problems (unstable or wrong results, or 
        excessively small timesteps), you may need to explicitly supply the 
        desired \Class{FaceVariable} rather than letting \FiPy{} 
        assume one.
    \end{reSTadmonition}
        
    \section{What does this error message mean?}\hspace*{\fill}
    
        \begin{itemize}
            
            \item ``\texttt{ValueError: frames are not aligned}''
            
            This error most likely means that you have provided a
            \Class{CellVariable} when \FiPy{} was expecting a
            \Class{FaceVariable} (or vice versa).

            \item ``\texttt{MA.MA.MAError: Cannot automatically
            convert masked array to Numeric because data is masked in one or
            more locations.}''
            
            This not-so-helpful error message could mean a number of things,
            but the most likely explanation is that the solution has become
            unstable and is diverging to $\pm\infty$.  This can be caused by
            taking too large a timestep or by using explicit terms instead of
            implicit ones.
            
            \item ``\texttt{repairing catalog by removing key}''
            
            This message (not really an error, but may cause test 
            failures) can result when using the \SciPy{} \weave{} 
            package via the \verb+--inline+ flag. It is due to a bug
            in \SciPy{} that has been patched in their source 
            repository: \url{http://www.scipy.org/mailinglists/mailman?fn=scipy-dev/2005-June/003010.html}.
            
            \item ``\texttt{numerix Numeric 23.6}''
            
            This is neither an error nor a warning. It's just sloppy 
            message left in \SciPy{}:
            \url{http://thread.gmane.org/gmane.comp.python.scientific.user/4349}.
            
        \end{itemize}

    \section{What if my question isn't answered here?}  
        
        Please post your question to the
        \href{http://www.ctcms.nist.gov/fipy/mail.html}{mailing list}
        \cite{FiPyMailingList} or
        \href{http://sourceforge.net/tracker/?group_id=118428}{file a
        Tracker request} \cite{FiPyBugTracker}.
