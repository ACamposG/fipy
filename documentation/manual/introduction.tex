\section{Research Background}

The equations that model the evolution of physical, chemical and
biological systems often have a remarkably universal form. Indeed,
partial differential equations (PDEs) have proven necessary to model
complex physical systems and processes that involve variations in both
space and time.  In general, given a variable of interest such as
species concentration, pH or temperature, there exists an evolution
equation of the form
\begin{equation}
  \frac{\partial \phi}{\partial t} = H(\phi, \lambda_i)
  \label{eqn:general-equation}
\end{equation}
where $H$ is a function of $\phi$, other state variables $\lambda_i$,
and higher order derivatives of all of these variables. Examples of
such systems are wide ranging, but include problems that exhibit a
combination of diffusing and reacting species, as well as such diverse
problems as determination of the electric potential in heart tissue,
of fluid flow, stress evolution, and even the Schroedinger equation.

The initial implementation of \FiPy{} has been developed to address
model problems in materials science such as poly-crystals, dendrititic
growth and electrochemical deposition. These applications all contain
various combinations of PDEs with differing forms in conjunction with
other unusual physics (over varying length scales) and unique solution
procedures. The philosophy of \FiPy{} is to enable unique
customization while providing a library of efficient modules for
common objects and data types.

\section{\FiPy{} Philosophy}

It is hard to estimate the future impact of a particular open source
project. However, we believe that the core principles used in the
development of \FiPy{} will enable it to have significant future
growth within the scientific community. The core principles of \FiPy{}
are outlined in some of the following sections.

\subsection{Object Oriented Approach}

\FiPy{} is programmed in an object-oriented manner. The benefit of object
oriented programming mainly lies in encapsulation and
inheritance. Encapsulation allows parts of the code to be separated
into clearly defined independent modules that can be re-applied or
extended in new ways. Inheritance allows code to be reused and new
capabilities to be added without altering the original code. These are
extremely powerful techniques.

\subsection{Test Based Development}

\FiPy{} has been developed with a large number of test cases. These test
cases operate on two levels. The lower level tests operate on the core
modules at the individual method level. Thus every method within the
core installation has a test case. The high level test cases operate
in conjunction with example test piece solutions and test global
solution algorithms and the interaction of various modules. Thus at
any stage in code development the test cases can be executed and
errors can be identified.

A test base is essential for the adoption of the code by new users and
developers. Many numerical codes do not have test bases available with
the code. This is a severe drawback in any prospective development
making it difficult to alter the code without the reassurance that any
code breakages will be clearly demonstrated with a broken test case. A
test base also aids dissemination of the code by providing simple
examples and knowledge of whether the code is working on a particular
computer environment.

\Python{} has modules (\doctest{}, \unittest{}) that automate the testing procedure.

\subsection{Documentation}

FiPY has been developed with a continuously updated manual. The manual
contains introductory material, installation procedures and
explanation of numerical algorithms. The manual also contains an
automated description of each module and method. The automated
description is derived from comments in the source code. Thus the
manual will stay current as the code develops and encourage developers
to comment the code. The same automated method is used to build
descriptions of core examples making it each for a prospective user to
understand and start using the code.

Many numerical codes do not have adequate documentation.

\subsection{Numerical Approach}

The solution algorithms given in the \FiPy{} examples involve combining
sets of PDEs while tracking an interface where the parameters of the
problem change rapidly. The Phase Field Method (PFM) and the Level Set
Method (LSM) are specialized techniques to handle the solution of
PDEs in conjunction with a deforming interface. The combination of
these methods within one code is novel and useful for academic as well
as practical comparison of both methods. Both methods are not new but
are still undergoing constant development.

\FiPy{} uses the well-known Finite Volume Method (FVM) to reduce the
model equations to a form tractable to linear solvers.

In general, both the LSM and PFM methods do not appear with standard
FV solvers, usually the more standard Volume Of Fluid Method (VOFM) is
used as an interface-tracking algorithm. Generally, VOFM is used for
very different applications to the LSM and PFM.

\subsection{Distribution}

Clear distribution techniques and easy installation are required for
prospective users to begin using the code. Two prospective methods are
planned for code distribution. The first method is simply creating
stable archive releases that users can unpack. The second method is to
create a code repository where users can update to the latest unstable
version of the code. This is useful to allow users access to the
latest bug fixes. Also having a central code repository allows more
developers to join the main project or select parts of the project.

Most numerical software is not distributed via a code repository and
thus makes obtaining the latest version of the software and bug fixes
difficult.

\subsection{Open Source}

In recent years there has been a movement towards more open source
unrestrictive licenses especially within the scientific community. The
\FiPy{} framework will be written with an open source license allowing
users to develop with complete access to the source code and then
either contribute back to the main source repository or freely
distribute their new adapted version. Many members of the scientific
community prefer to use an open source license due to the unrestricted
access and ability to develop extensible codes. Specifically, the
restrictions of non-open source licenses involve an inability to
redistribute code, a lack of access to source code and the expense of
maintaining licenses. Redistribution of code not only allows tools to
be shared but also promotes communication of ideas. Access to source
code is essential for developers and users to understand the function
of a code and allow bugs to be fixed.

\subsection{Pair Programming}

\href{http://www.extremeprogramming.org/rules/pair.html}{Pair programming}
is a good way to develop computer code.

\subsection{\Python{} Programming Language}

\Python{} combines remarkable power with very clear syntax. It is
freely usable and distributable, even for commercial use. \Python{} is
an example of an interpreted scripting language. Scripting languages
are seen as distinctive from compiled lower level languages such as C
or FORTRAN. Such lower level languages are commonly used for numerical
codes due to their increased efficiency over scripting languages. This
makes \Python{} an unusual choice for the bases of a numerical
framework.

Codes, programmed exclusively in C or FORTRAN, are often hard to
readapt to new application areas mainly due to the inability to allow
developers access at various levels of the code. In general, such
codes use a distinctive scripting language written for the code at
hand allowing users to vary parameter values and switch between
different internal solution algorithms. Such exclusive scripting
languages can often be difficult to write and must be an integral part
of the design of the numerical code and cannot easily account for the
various ways a prospective user may wish to use the code.

Thus \FiPy{}, rather than taking the approach of writing the fast
numerical code first and then dealing with the issue of user
interaction, initially implements most modules in the \Python{}
scripting language and only translates to C those parts of the code
that prove inefficient. This leads to most top-level structures being
written in \Python{} allowing easy to understand implementation and
modification. The choice of \Python{} is in part due to the easy
integration of C either as separate modules or encapsulated in
\Python{} functions as well as the ability to directly translate from
\Python{} to C (\PyRex{}). This low-level integration has resulted
in a number of freely available efficient numerical modules (\SciPy{},
\Numeric{}) for \Python{} some of which are utilized in the \FiPy{}
framework.

\section{Contributions}

\section{Sourceforgre}

Mailing lists, bug tracking, 

\section{Outstanding Issues}

\subsection{Efficiency}

\subsection{Memory Usage}