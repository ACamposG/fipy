#!/usr/bin/env python

## 
 # ###################################################################
 #  FiPy - Python-based finite volume PDE solver
 # 
 #  FILE: "rotation.py"
 #
 #  Author: Jonathan Guyer <guyer@nist.gov>
 #  Author: Daniel Wheeler <daniel.wheeler@nist.gov>
 #  Author: James Warren   <jwarren@nist.gov>
 #    mail: NIST
 #     www: http://www.ctcms.nist.gov/fipy/
 #  
 # ========================================================================
 # This software was developed at the National Institute of Standards
 # and Technology by employees of the Federal Government in the course
 # of their official duties.  Pursuant to title 17 Section 105 of the
 # United States Code this software is not subject to copyright
 # protection and is in the public domain.  FiPy is an experimental
 # system.  NIST assumes no responsibility whatsoever for its use by
 # other parties, and makes no guarantees, expressed or implied, about
 # its quality, reliability, or any other characteristic.  We would
 # appreciate acknowledgement if the software is used.
 # 
 # This software can be redistributed and/or modified freely
 # provided that any derivative works bear some notice that they are
 # derived from it, and any modified versions bear some notice that
 # they have been modified.
 # ========================================================================
 #  
 # ###################################################################
 ##

r"""

This example demonstrates the use of the
:class:`fipy.terms.roeConvectionTerm.RoeConvectionTerm` for a single
equation. The example is taken from the Clawpack code and the results
are compared with data generated by Clawpack. The example solves
solid-body rotation for circular and square regions using the
advection equation given by,

.. math::
   
   \frac{\partial \phi}{\partial t} + \nabla \left( \vec{u} \phi \right) = 0

with

.. math::

   \vec{u} = \left(2 y, -2 x \right)

>>> from fipy import *

>>> N = 80
>>> L = 2.
>>> dx = L / N 
>>> origin =[[-1], [-1]]

>>> mesh = Grid2D(nx=N, ny=N, dx=dx, dy=dx) + origin

>>> var = CellVariable(mesh=mesh, hasOld=True)

Set the intitial circular and square regions shown in the image below.

>>> def initialize(v):
...     v[:] = 0.
...     ## square
...     v[(0.1 < mesh.x) & (mesh.x < 0.6) & (-0.25 < mesh.y) & (mesh.y < 0.25)] = 1.
...     ##circle
...     r = numerix.sqrt((mesh.x + 0.45)**2 + mesh.y**2)
...     v[r < 0.35] = (1 - r / 0.35)[r < 0.35]

>>> initialize(var)

Set the initial velocity field in the manner used in Clawpack for comparison purposes.

>>> vel = FaceVariable(mesh=mesh, rank=1)
>>> def psi(x, y):
...     return x**2 + y**2
>>> X, Y = mesh.faceCenters
>>> vel[0] = (psi(X, Y + mesh.dy / 2) - psi(X, Y - mesh.dy / 2)) / mesh.dy
>>> vel[1] = -(psi(X + mesh.dx / 2, Y) - psi(X - mesh.dx / 2., Y)) / mesh.dx

Initially use only a first order
(:class:`fipy.terms.firstOrderRoeConvectionTerm.FirstOrderRoeConvectionTerm`)
scheme to compare with Clawpack.

>>> eqn = TransientTerm() + FirstOrderRoeConvectionTerm(vel)

>>> if __name__ == '__main__':
...     viewer = Viewer(var)
...     viewer.plot()
...     raw_input("Solid-body rotation initial conditions. Press <return> to proceed...")

.. image:: rotationInitialConditions.*
   :width: 90%
   :align: center
   :alt: Initial conditions for solid-body rotation.

-----

>>> elapsed = 0.0
>>> dt = 0.0009
>>> ##def run():
>>> numerix.savetxt('data0.txt', var.value)


>>> for i in range(50):
...     var.updateOld()
...     eqn.solve(var, dt=dt)
...     elapsed += dt
...     if i % 10 == 0 and __name__ == '__main__':
...         viewer.plot()

>>> import os 
>>> filepath = os.path.splitext(__file__)[0] + 'FirstOrder.gz'
>>> print var.allclose(numerix.loadtxt(filepath, skiprows=9))
True

>>> if __name__ == "__main__":
...     raw_input("First order scheme. Press <return> to proceed...")

>>> initialize(var)
>>> eqn = TransientTerm() + RoeConvectionTerm(vel)

>>> for i in range(50):
...     var.updateOld()
...     eqn.solve(var, dt=dt)
...     elapsed += dt
...     if i % 10 == 0 and __name__ == '__main__':
...         viewer.plot()

>>> import os 
>>> filepath = os.path.splitext(__file__)[0] + 'SecondOrder.gz'
>>> print var.allclose(numerix.loadtxt(filepath, skiprows=9))
True

>>> if __name__ == "__main__":
...     raw_input("Second order scheme. Press <return> to proceed...")



"""

__docformat__ = 'restructuredtext'

if __name__ == '__main__':
    import fipy.tests.doctestPlus
    exec(fipy.tests.doctestPlus._getScript())
