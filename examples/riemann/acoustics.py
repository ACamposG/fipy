#!/usr/bin/env python

## 
 # ###################################################################
 #  FiPy - Python-based finite volume PDE solver
 # 
 #  FILE: "acoustics.py"
 #
 #  Author: Jonathan Guyer <guyer@nist.gov>
 #  Author: Daniel Wheeler <daniel.wheeler@nist.gov>
 #  Author: James Warren   <jwarren@nist.gov>
 #    mail: NIST
 #     www: http://www.ctcms.nist.gov/fipy/
 #  
 # ========================================================================
 # This software was developed at the National Institute of Standards
 # and Technology by employees of the Federal Government in the course
 # of their official duties.  Pursuant to title 17 Section 105 of the
 # United States Code this software is not subject to copyright
 # protection and is in the public domain.  FiPy is an experimental
 # system.  NIST assumes no responsibility whatsoever for its use by
 # other parties, and makes no guarantees, expressed or implied, about
 # its quality, reliability, or any other characteristic.  We would
 # appreciate acknowledgement if the software is used.
 # 
 # This software can be redistributed and/or modified freely
 # provided that any derivative works bear some notice that they are
 # derived from it, and any modified versions bear some notice that
 # they have been modified.
 # ========================================================================
 #  
 # ###################################################################
 ##

r"""

This example demonstrates the use of the
:class:`fipy.terms.roeConvectionTerm.RoeConvectionTerm` for coupled
equations with constant coefficients. The example is taken from the
Clawpack_ code and the results are compared with data generated by
Clawpack_. The example solves an acoustics problem for pressure and
velocity for a system linearized about the motionless state.

.. math::
   
   \partial_t p + K_0 \partial_x u &= 0 \\
   \rho_0 \partial_t u + \partial_x p &= 0
   
This can be written in the following form

.. math::

   \partial_t q^i + A^{ki}_j \partial_k q^j = 0

where :math:`k` is over the number of dimensions, :math:'i' is over
the number of equations and :math:'j' are is the number of variables,
although the number of variables should always equal the number of
equations. In matrix form these are,

.. math::

   q = \begin{pmatrix} 
         p \\ 
         u 
   \end{pmatrix}

and

.. math::

   A = \begin{pmatrix} 
         0 & K_0 \\ 
         1/\rho_0 & 0 
   \end{pmatrix}

>>> from fipy import Grid1D, CellVariable, numerix, RoeConvectionTerm
>>> from fipy import Viewer, TransientTerm, FirstOrderRoeConvectionTerm

The solution is in :math:`[-1, 1]` with 800 cells.

>>> L = 2.
>>> X0 = -1.
>>> N = 800
>>> K0 = 4.
>>> rho0 = 1
>>> cfl = 0.9

>>> dx = L / N

Here we add in 2 extra ghost cells on the left hand side of the domain
for an unusual boundary condition.

>>> m = Grid1D(nx=N + 2, dx=dx) + (X0 - 2 * dx)
>>> x, = m.cellCenters
>>> X, = m.faceCenters

Here ``q[0]`` is :math:`p` and ``q[1]`` is :math:`u`.

>>> q = CellVariable(mesh=m, rank=1, elementshape=(2,))

The boundary condition on the left is a reflecting wall while the
right is a more standard outlet condition. The outlet on the right can
be represented with the following constraint.

>>> q.faceGrad.constrain(0, [X == 1, X == 1])

A second order accurate reflecting boundary condition is currently not
possible with the variable constraint semantics so a function,
``setBCs``, is used to reset the ghost node values at each step. The
reflecting boundary condition at :math:`x = -1` can be written,
   
.. math::

   p \left( -1 - \xi, t \right) &= p \left( -1 + \xi, t \right) \\
   u \left( -1 - \xi, t \right) &= -u \left( -1 + \xi, t \right)

This can be represented using ghost nodes for second order accuracy in
the following way.

>>> def setBCs(q):
...     q[0,0] = q[0,3]
...     q[0,1] = q[0,2]
...     q[1,0] = -q[1,3]
...     q[1,1] = -q[1,2]

Set the initial conditions and plot the fields.

>>> q[0,:] = numerix.exp(-50 * (x - 0.3)**2) * numerix.cos(20 * (x - 0.3))
>>> q[0, x > 0.3] = 0.
>>> setBCs(q)

>>> if  __name__ == '__main__':
...     p, u = q[0], q[1]
...     p.name = r'$p$'
...     u.name = r'$u$'  
...     vi = Viewer((p, u), datamin=-0.4, datamax=1.)
...     vi.plot('acousticsInitialConditions.png')
...     raw_input("Acoustics initial conditions. Press <return> to proceed...")

.. image:: acousticsInitialConditions.*
   :width: 90%
   :align: center
   :alt: Initial conditions for the acoustics problem.

The tensor :math:`A^{ki}_j` is represnted as a ``CellVariable`` of
shape ``(1, 2, 2, 802)`` with indices of :math:`\left(k, i, j,
N\right)`.

>>> Ax = CellVariable(mesh=m, rank=3, value=[((0, K0), (1 / rho0, 0))], elementshape=(1, 2, 2))

>>> eqn = TransientTerm() + RoeConvectionTerm(Ax) == 0

The time step is calculated by asking the equation for it's largest
eigenvalue.

>>> dt = cfl * dx / eqn.maxeigenvalue(q)

First we do 100 steps ...

>>> for step in range(100):
...     eqn.solve(q, dt=dt)
...     setBCs(q)
...     if step % 20 ==  0 and  __name__ == '__main__':
...         vi.plot('acoustics100.png')

.. image:: acoustics100.*
   :width: 90%
   :align: center
   :alt: Initial conditions for the acoustics problem.

and comapre the results with Clawpack_ data.

>>> import os 
>>> filepath = os.path.splitext(__file__)[0] + 'Clawpack100.gz'
>>> print q[:,2:].allclose(numerix.loadtxt(filepath, skiprows=6).swapaxes(0,1))
True

>>> if __name__ == '__main__':
...     raw_input("After 100 steps. Press <return> to proceed...")

We then do a further 600 steps in order for the waves to be reflected
at the left hand boundary ...

>>> for step in range(600):
...     eqn.solve(q, dt=dt)
...     setBCs(q)
...     if step % 20 ==  0 and  __name__ == '__main__':
...         vi.plot()

>>> if __name__ == '__main__':
...     raw_input("After a reflection. Press <return> to proceed...")

and comapre with Clawpack_ once more.

>>> filepath = os.path.splitext(__file__)[0] + 'Clawpack700.gz'
>>> print q[:,2:].allclose(numerix.loadtxt(filepath, skiprows=6).swapaxes(0,1))
True

To test the first order scheme, we remove the ghost cells from the
mesh and use the
:class:`fipy.terms.firstOrderRoeConvectionTerm.FirstOrderRoeConvectionTerm`.

>>> mesh = Grid1D(nx=N, dx=dx) + X0
>>> x, = mesh.cellCenters
>>> X, = mesh.faceCenters
>>> qFirst = CellVariable(mesh=mesh, rank=1, elementshape=(2,))

The boundary conditions can be represented without ghost cells in the
first order case.

>>> qFirst.faceGrad.constrain(0, [(X == -1) | (X == 1), X == 1])
>>> qFirst.constrain(0, [X == -10, X == -1])

Initial conditions.

>>> qFirst[0,:] = numerix.exp(-50 * (x - 0.3)**2) * numerix.cos(20 * (x - 0.3))
>>> qFirst[0, x > 0.3] = 0.
>>> Ax = CellVariable(mesh=mesh, rank=3, value=[((0, K0), (1 / rho0, 0))], elementshape=(1, 2, 2))
>>> eqn = TransientTerm() + FirstOrderRoeConvectionTerm(Ax) == 0

>>> for step in range(700):
...     eqn.solve(qFirst, dt=dt)

Compare the results with Clawpack_ data.

>>> import os
>>> filepath = os.path.splitext(__file__)[0] + 'FirstOrderClawpack.gz'
>>> print qFirst[:,:].allclose(numerix.loadtxt(filepath, skiprows=6).swapaxes(0,1))
True

Finally compare the first and second order pressure fields.

>>> if  __name__ == '__main__':
...     p1 = qFirst[0]
...     p1.name = r'$p, O\left(\Delta x\right)$'
...     p2 = p1.copy()
...     p2.name = r'$p, O\left(\left(\Delta x\right)^2\right)$'
...     p2[:] = q[0,2:]
...     vi = Viewer((p1, p2), datamax=0.7)
...     vi.plot('acoustics.png')
...     raw_input("Acoustics 1st and 2nd order comparison. Press <return> to proceed...")

.. image:: acoustics.*
   :width: 90%
   :align: center
   :alt: Comparison of the first and second order schemes.

"""

__docformat__ = 'restructuredtext'

if __name__ == '__main__':
    import fipy.tests.doctestPlus
    exec(fipy.tests.doctestPlus._getScript())

    raw_input('finished')
