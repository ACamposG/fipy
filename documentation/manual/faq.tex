\minitoc[e]
    
    \section{How do I represent an equation in \FiPy{}?}
    
    As explained in Chapter~\ref{chap:Numerics}, the canonical
    governing equation that can be solved by \FiPy{} for the dependent
    \Class{CellVariable} $\phi$ is
        \begin{equation}                        
             \underbrace{
               \frac{\partial (\rho \phi)}{\partial t}
             }_{\text{transient}}
             =
             \underbrace{
               \vphantom{\frac{\partial (\rho \phi)}{\partial t}}
               \nabla \cdot \left( \vec{u} \phi \right)
             }_{\text{convection}}
             +
             \underbrace{
               \vphantom{\frac{\partial (\rho \phi)}{\partial t}}
               \left[ \nabla \cdot \left( \Gamma_i \nabla \right) \right]^n \phi
             }_{\text{diffusion}}
             +
             \underbrace{
               \vphantom{\frac{\partial (\rho \phi)}{\partial t}}
               S_{\phi}
             }_{\text{source}}
             \tag{\ref{eqn:num:gen}}
        \end{equation}
        A physical problem can involve many different coupled
        governing equations, one for each variable.  Numerous specific
        examples are presented in Part~\ref{part:Examples}, but let us
        examine this general expression term-by-term:
        
            \subsection{How do I represent a transient term 
            $\partial (\rho \phi) / \partial t$?}
            \hspace*{\fill}
            
            \begin{quote}
\begin{verbatim}
>>> TransientTerm(coeff = rho)
\end{verbatim}
            \end{quote}
          
            \begin{reSTadmonition}[Note]
                We have specified neither the variable $\phi$ nor the time
                step.  Both are handled when we actually solve the equation.
            \end{reSTadmonition}
            
            \subsection{How do I represent a convection term
            $\nabla \cdot \left( \vec{u} \phi \right)$?}
            \hspace*{\fill}
            
            \begin{quote}
\begin{verbatim}
>>> <Specific>ConvectionTerm(coeff = u, 
...                          diffusionTerm = diffTerm)
\end{verbatim}
            \end{quote}
            where \verb|<Specific>| can be any of \verb|CentralDiff|,
            \verb|Exponential|, \verb|Hybrid|, \verb|PowerLaw|,
            \verb|Upwind|, \verb|ExplicitUpwind|, or \verb|VanLeer|.
            The differences between these convection schemes are described
            in Section~\ref{sec:NumericalSchemes}. The velocity coefficient 
            \verb|u| must be a rank-1 \Class{FaceVariable}, or a 
            constant vector in the form of a Python list or tuple, 
            \emph{e.g.} \verb|((1,), (2,))| for a vector in 2D.
            
            \begin{reSTadmonition}[Note]
                As discussed in Section~\ref{sec:NumericalSchemes}, the
                convection schemes need to calculate a P\'eclet number,
                and therefore need to know about any diffusion term
                used in the problem.  It is hoped that this dependency
                can be automated in the future.
            \end{reSTadmonition}
            
            \begin{reSTadmonition}[Warning]
                \Class{VanLeerConvectionTerm} not mentioned and no discussion of
                explicit forms.
            \end{reSTadmonition}
        
            \subsection{How do I represent a diffusion term
            $\nabla \cdot \left( \Gamma_1 \nabla \phi \right)$?}
            \hspace*{\fill}
            
            Either
           \begin{quote}
\begin{verbatim}
>>> ImplicitDiffusionTerm(coeff = Gamma1)
\end{verbatim}
           \end{quote}
           or 
           \begin{quote}
\begin{verbatim}
>>> ExplicitDiffusionTerm(coeff = Gamma1)
\end{verbatim}
           \end{quote}
           \Class{ExplicitDiffusionTerm} is provided only for illustrative purposes.
           \Class{ImplicitDiffusionTerm} is almost always preferred (\Class{DiffusionTerm} is a synonym for \Class{ImplicitDiffusionTerm} to reinforce this preference). It is
           theoretically possible to create an explicit diffusion term with
           \begin{quote}
\begin{verbatim}
>>> (Gamma1 * phi.getFaceGrad()).getDivergence()
\end{verbatim}
           \end{quote}
           Unfortunately, in this form, any boundary conditions on $\phi$
           will not be accounted for.

            
           
           \subsection{How do I represent a term $\nabla^4 \phi$ or
            $\nabla \cdot \left( \Gamma_1 \nabla \left(
            \nabla\cdot\left( 
            \Gamma_2 \nabla \phi\right) \right) \right) $ such as for 
            Cahn-Hilliard? \label{FAQ-higherOrderDiffusion}}
          \hspace*{\fill}
            
          \begin{quote}
\begin{verbatim}
>>> ImplicitDiffusionTerm(coeff = (Gamma1, Gamma2))
\end{verbatim}
          \end{quote}
          The number of elements supplied for \verb|coeff| determines the
          order of the term.

          \subsection{Is there a way to model an anisotropic diffusion
            process or more generally to represent the diffusion
            coefficient as a tensor so that the diffusion term takes the
            form $\partial_i \Gamma_{ij}\partial_j \phi$?}
          Terms of the form $\partial_i \Gamma_{ij}\partial_j \phi$ can
          be posed in \FiPy{} by using a list, tuple, rank 1 or rank 2
          \Class{FaceVariable} to represent a vector or tensor diffusion
          coefficient.  For example, if we wished to represent a
          diffusion term with an anisotropy ratio of 5 aligned along the
          x-coordinate axis, we could write the term as,
\begin{verbatim}
>>> DiffusionTerm([[[5, 0], [0, 1]]])
\end{verbatim}
          which represents $5 \partial_x^2 + \partial_y^2$.  Notice that
          the tensor, written in the form of a list, is contained within
          a list. This is because the first index of the list refers to
          the order of the term not the first index of the tensor (see
          the FAQ, Chapter~\ref{FAQ-higherOrderDiffusion}
          ``\titleref{FAQ-higherOrderDiffusion}''). This
          notation, although succinct can sometimes be confusing so a
          number of cases are interpreted below.
          \begin{itemize}

            \item
\begin{verbatim}
>>> DiffusionTerm([[5, 1]])
\end{verbatim}
              This represents the same term as the case examined above.
              The vector notation is just a short-hand representation
              for the diagonal of the tensor. Off-diagonals are assumed
              to be zero.

            \item
\begin{verbatim}
>>> DiffusionTerm([5, 1])
\end{verbatim}
              This simply represents a fourth order isotropic diffusion
              term of the form $5 \left( \partial_x^2 + \partial_y^2
              \right)^2$.

            \item 
\begin{verbatim}
>>> DiffusionTerm([[1, 0], [0, 1]])
\end{verbatim}
              Nominally, this should represent a fourth order diffusion
              term of the form $\partial_x^2 \partial_y^2$, but \FiPy{}
              does not currently support anisotropy for higher order
              diffusion terms so this may well throw an error or give
              anomalous results.
            
            \item
\begin{verbatim}
>>> x, y = mesh.getCellCenters()
>>> DiffusionTerm([[[x**2, x * y], [-x * y, -y**2]]])
\end{verbatim}
              This represents an anisotropic diffusion coefficient that
              varies spatially so that the term has the form 
              $\partial_x (x^2 \partial_x + x y \partial_y)
              + \partial_y (-x y \partial_x - y^2 \partial_y)
              \equiv x \partial_x - y \partial_y + x^2 \partial_x^2 - y^2
              \partial_y^2$.

            \item Generally, anisotropy is not conveniently aligned
              along the coordinate axes; in these cases, it is necessary
              to apply a rotation matrix in order to calculate the
              correct tensor values, see
              Chapter~\ref{sec:Examples:diffusion:anisotropy}
              ``\titleref{sec:Examples:diffusion:anisotropy}'' for
              details.

            \end{itemize}

            \subsection{What if the term isn't one of those?}
            Any term that cannot be written in one of the previous
            forms is considered a source $S_{\phi}$. An explicit
            source is written in Python essentially as it appears in
            mathematical form, \emph{e.g.}, $3\kappa^2 + b \sin
            \theta$ would be written
            \begin{quote}
\begin{verbatim}
>>> 3 * kappa**2 + b * sin(theta)
\end{verbatim}
            \end{quote}
            
            \begin{reSTadmonition}[Note]
                Functions like \verb+sin()+ can be obtained from the
                \EpydocDottedName{fipy.tools.numerix} module.
                \begin{reSTadmonition}[Warning]
                    Generally, things will not work as expected if the
                    equivalent function is used from the \NumPy{} or \SciPy{}
                    library.
                \end{reSTadmonition}
            \end{reSTadmonition}
            
            If, however, the source depends on the variable that is being solved for,
            it can be advantageous to linearize the source and cast part of it as an
            implicit source term, \emph{e.g.}, $3\kappa^2 + \phi \sin \theta$
            might be written as
            \begin{quote}
\begin{verbatim}
>>> 3 * kappa**2 + ImplicitSourceTerm(coeff = sin(theta))
\end{verbatim}
            \end{quote}
            
            \subsection{How do I represent a \dots{} term that 
            \emph{doesn't} involve the dependent variable?}
            It is important to realize that, even though an expression may
            superficially resemble one of those shown above, if the
            dependent variable \emph{for that PDE} does not appear in the
            appropriate place, then that term should be treated as a source.

                \subsubsection{How do I represent a diffusive source?}
                    If the governing equation for $\phi$ is
                    \[
                        \frac{\partial \phi}{\partial t} 
                        = \nabla\cdot\left( D_1 \nabla \phi\right)
                        + \nabla\cdot\left( D_2 \nabla \xi\right)
                    \]
                    then the first term is a \Class{TransientTerm} and the second term 
                    is a \Class{DiffusionTerm}, but the third term is 
                    simply an explicit source, which is written in Python as
                    \begin{quote}
\begin{verbatim}
>>> (D2 * xi.getFaceGrad()).getDivergence()
\end{verbatim}
                    \end{quote}
                    Higher order diffusive sources can be obtained by
                    simply nesting the calls to \verb+getFaceGrad()+
                    and \verb+getDivergence()+.
                    \begin{reSTadmonition}[Note]
                        We use \verb|getFaceGrad()|, rather than
                        \verb|getGrad()|, in order to obtain a
                        second-order spatial discretization of the
                        diffusion term in $\xi$, consistent with the
                        matrix that is formed by
                        \Class{DiffusionTerm} for $\phi$.
                    \end{reSTadmonition}

                \subsubsection{How do I represent a convective source?}
                    The convection of an independent field $\xi$ as in
                    \[
                        \frac{\partial \phi}{\partial t} 
                        = \nabla\cdot
                        \left(
                            \vec{u} \xi
                        \right)
                    \]
                    can be rendered as
                    \begin{quote}
\begin{verbatim}
>>> (u * xi.getArithmeticFaceValue()).getDivergence()
\end{verbatim}
                    \end{quote}
                    when $\vec{u}$ is a rank-1 \Class{FaceVariable} 
                    (preferred) or as
                    \begin{quote}
\begin{verbatim}
>>> (u * xi).getDivergence()
\end{verbatim}
                    \end{quote}
                    if $\vec{u}$ is a rank-1 \Class{CellVariable}.


                \subsubsection{How do I represent a transient source?}
                    The time-rate-of change of an independent variable
                    $\xi$, such as in
                    \[
                        \frac{\partial (\rho_1 \phi)}{\partial t}
                        = \frac{\partial (\rho_2 \xi)}{\partial t}
                    \]
                    does not have an abstract form in \FiPy{} and
                    should be discretized directly, in the manner of
                    Equation~\eqref{eqn:num:tra}, as
                    \begin{quote}
\begin{verbatim}
>>> TransientTerm(coeff = rho1) == rho2 * (xi - xi.getOld()) / timeStep
\end{verbatim}
                    \end{quote}
                    This technique is used in
                    Example~\ref{examples:phase:anisotropy}.
                    
        \subsection{What if my term involves the dependent variable, 
            but not where \FiPy{} puts it?}
            
            Frequently, viewing the term from a different perspective
            will allow it to be cast in one of the canonical forms.
            For example, the third term in
            \[
                \frac{\partial \phi}{\partial t} 
                = \nabla\cdot\left( D_1 \nabla \phi\right)
                + \nabla\cdot\left( D_2 \phi \nabla \xi\right)
            \]
            might be considered as the diffusion of the independent
            variable $\xi$ with a mobility $D_2\phi$ that is a
            function of the dependent variable $\phi$.  For \FiPy{}'s
            purposes, however, this term represents the convection of
            $\phi$, with a velocity $D_2\nabla\xi$, due to the
            counter-diffusion of $\xi$, so
            \begin{quote}
\begin{verbatim}
>>> diffTerm = DiffusionTerm(coeff = D1)
>>> convTerm = <Specific>ConvectionTerm(coeff = D2 * xi.getFaceGrad(), 
...                                     diffusionTerm = diffTerm)
>>> eq = TransientTerm() == diffTerm + convTerm
\end{verbatim}
            \end{quote}

        \subsection{What if the coefficient of a term depends on 
            the variable that I'm solving for?}
            
            A non-linear coefficient, such as the diffusion 
            coefficient in \( 
            \nabla\cdot[\Gamma_1(\phi) \nabla \phi] = 
            \nabla\cdot[\Gamma_0 \phi (1 - \phi) \nabla\phi] \) is 
            not a problem for \FiPy. Simply write it as it appears:
            \begin{quote}
\begin{verbatim}
>>> diffTerm = DiffusionTerm(coeff = Gamma0 * phi * (1 - phi))
\end{verbatim}
            \end{quote}
            \begin{reSTadmonition}[Note]
            Due to the nonlinearity of the coefficient, it will
            probably be necessary to ``sweep'' the solution to
            convergence as discussed in
            FAQ~\ref{FAQ-IterationsTimestepsSweeps}.
            \end{reSTadmonition}


    \section{How can I see what I'm doing?}
    
    \subsection{How do I export data?} The way to save your calculations
    depends on how you plan to make use of the data. If you want to
    save it for ``restart'' (so that you can continue or redirect a
    calculation from some intermediate stage), then you'll want to
    ``pickle'' the \Python{} data with the \Module{dump} module. This
    is illustrated in Examples~\ref{examples:phase:anisotropy},
    \ref{examples:phase:impingement:mesh40x1},
    \ref{examples:phase:impingement:mesh20x20}, and
    \ref{examples:levelSet:electroChem:howToWriteAScript}.
    
    On the other hand, pickled \FiPy{} data is of little use to
    anything besides \Python{} and \FiPy{}. If you want to import your
    calculations into another piece of software, whether to make
    publication-quality graphs or movies, or to perform some analysis,
    or as input to another stage of a multiscale model, then you can
    save your data as an \textsc{ascii} text file of
    tab-separated-values with a \Class{TSVViewer}. This is 
    illustrated in Example~\ref{examples:diffusion:circle}.
    
    \subsection{How do I save a plot image?} Some of the viewers have a
    button or other mechanism in the user interface for saving an
    image file. Also, you can supply an optional keyword
    \verb+filename+ when you tell the viewer to \verb+plot()+,
    \emph{e.g.}
    \begin{quote}
\begin{verbatim}
>>> viewer.plot(filename="myimage.ext")
\end{verbatim}
    \end{quote}
    which will save a file named \verb+myimage.ext+ in your current
    working directory. The type of image is determined by the file
    extension ``\verb+.ext+''. Different viewers have different
    capabilities: 
    
        \begin{description}
            \item[\Pygist{}] accepts ``\verb+.eps+''
            (\href{http://en.wikipedia.org/wiki/Encapsulated_PostScript}{Encapsulated
            PostScript}) and ``\verb+.cgm+''
            (\href{http://xml.coverpages.org/cgm.html}{Computer
            Graphics Metafile}).
        
            \item[\gnuplot{}] accepts ``\verb+.eps+''.
        
            \item[\Matplotlib{}] accepts ``\verb+.eps+'',
            ``\verb+.jpg+'' (\href{http://www.jpeg.org/}{Joint
            Photographic Experts Group}), and ``\verb+.png+''
            (\href{http://www.w3.org/Graphics/PNG/}{Portable Network
            Graphics}).
            
            \begin{reSTadmonition}[Attention]
                Actually, \Matplotlib{} supports different 
                extensions, depending on the chosen 
                \href{http://matplotlib.sourceforge.net/backends.html}{backend}, but our 
                \Class{MatplotlibViewer} classes don't properly 
                support this yet.
            \end{reSTadmonition}
            
        \end{description}
        
    \Pygist{}  \Matplotlib{} accepts ``\verb+.eps+'', ``\verb+.jpg+''
    (\href{http://www.jpeg.org/}{Joint Photographic Experts Group}),
    and ``\verb+.png+''
    (\href{http://www.w3.org/Graphics/PNG/}{Portable Network
    Graphics}). \MayaVi{} only accepts ``\verb+.png+''. \gnuplot{} 
    only accepts ``\verb+.eps+''.
    
        \subsubsection{What if I only want the saved file, with no
        display on screen?} To our knowledge, this is only supported
        by \Matplotlib{}, as is explained in the
        \href{http://matplotlib.sourceforge.net/faq/howto_faq.html#generate-images-without-having-a-window-popup}{\Matplotlib{}
        FAQ}. Basically, you need to tell \Matplotlib{} to use an
        ``image backend'', such as ``Agg'' or ``Cairo''. Backends are
        discussed at
        \url{http://matplotlib.sourceforge.net/backends.html}.
        

    \subsection{How do I make a movie?} \FiPy{} has no facilities for 
    making movies. You will need to save individual frames (see the 
    previous question) and then stitch them together into a movie, 
    using one of a variety of different free, shareware, or 
    commercial software packages. The guidance in the 
    \href{http://matplotlib.sourceforge.net/faq/howto_faq.html#make-a-movie}{\Matplotlib{}
    FAQ} should be adaptable to other \Class{Viewer}s.
    
    \subsection{Why don't the \Class{Viewer}s look the way I want?}
    \FiPy's viewers are utilitarian. They're designed to let you see 
    \emph{something} with a minimum of effort. Because different 
    plotting packages have different capabilities and some are easier 
    to install on some platforms than on others, we have tried to 
    support a range of \Python{} plotters with a minimal common set of 
    features. Many of these packages are capable of much more, 
    however. Often, you can invoke the \Class{Viewer} you want, and 
    then issue supplemental commands for the underlying plotting 
    package. The better option is to make a ``subclass'' of the 
    \FiPy{} \Class{Viewer} that comes closest to producing the image 
    you want. You can then override just the behavior you wan to 
    change, while letting \FiPy{} do most of the heavy lifting. See 
    \ref{examples:phase:anisotropy} for an example of creating a custom 
    \Matplotlib{} \Class{Viewer} class.
    
    \section{Iterations, timesteps, and sweeps? Oh, my!} 
    \label{FAQ-IterationsTimestepsSweeps}
    Any non-linear solution of partial differential equations is an
    approximation. These approximations benefit from repetetive
    solution to achieve the best possible answer. In \FiPy{} (and in
    many similar PDE solvers), there are three layers of repetition.
    
    \begin{description}
    
        \item[iterations] This is the lowest layer of repetition,
        which you'll generally need to spend the least time thinking
        about. \FiPy{} solves PDEs by discretizing them into a set of
        linear equations in matrix form, as explained in
        Sections~\ref{section:discretization} and
        \ref{section:linear-equations}. It is not always practical, or
        even possible, to exactly solve these matrix equations on a
        computer. \FiPy{} thus employs ``iterative solvers'', which
        make successive approximations until the linear equations have
        been satisfactorily solved. \FiPy{} chooses a default number
        of iterations and solution tolerance, which you will not
        generally need to change. If you do wish to change these
        defaults, you'll need to create a new \Class{Solver} object
        with the desired number of iterations and solution tolerance,
        \emph{e.g.}
        \begin{quote}
\begin{verbatim}
>>> mySolver = LinearPCGSolver(iterations=1234, tolerance=5e-6) 
    : 
    :
>>> eq.solve(..., solver=mySolver, ...)
\end{verbatim}
    	\end{quote}
        \begin{reSTadmonition}[Note]
        The older \Class{Solver} \verb+steps=+ keyword is now
        deprecated in favor of \verb+iterations=+ to make the role
        clearer.
        \end{reSTadmonition}
        Solver iterations are changed from their defaults in
        Examples~\ref{examples:flow:stokesCavity} and
        \ref{examples:update0-1to1-0}.
        % ~\ref{Examples:cahnHilliard:inputTanh1D},
        
        \item[sweeps] This middle layer of repetition is important
        when a PDE is non-linear (\emph{e.g.}, a diffusivity that
        depends on concentration) or when multiple PDEs are coupled
        (\emph{e.g.}, if solute diffusivity depends on temperature and
        thermal conductivity depends on concentration). Even if the
        \Class{Solver} solves the \emph{linear} approximation of the
        PDE to absolute perfection by performing an infinite number of
        iterations, the solution may still not be a very good
        representation of the actual \emph{non-linear} PDE. If we
        resolve the same equation \emph{at the same point in elapsed
        time}, but use the result of the previous solution instead of 
        the previous timestep, then we can get a refined solution to 
        the \emph{non-linear} PDE in a process known as ``sweeping.'' 
        \begin{reSTadmonition}[Note]
        Despite references to the ``previous timestep,'' sweeping is 
        not limited to time-evolving problems. Nonlinear sets of 
        quasi-static or steady-state PDEs can require sweeping, too.
        \end{reSTadmonition}
        We need to distinguish between the value of the variable at
        the last timestep and the value of the variable at the last
        sweep (the last cycle where we tried to solve the
        \emph{current} timestep). This is done by first modifying the
        way the variable is created:
        \begin{quote}
\begin{verbatim}
>>> myVar = CellVariable(..., hasOld=1)
\end{verbatim}
        \end{quote}
        and then by explicitly moving the current value of the 
        variable into the ``old'' value only when we want to:
        \begin{quote}
\begin{verbatim}
>>> myVar.updateOld()
\end{verbatim}
        \end{quote}
        Finally, we will need to repeatedly solve the equation until 
        it gives a stable result. To clearly distinguish that a 
        single cycle will not truly ``solve'' the equation, we invoke 
        a different method ``\verb+sweep()+''\IndexFunction{sweep}:
        \begin{quote}
\begin{verbatim}
>>> for sweep in range(sweeps):
...     eq.sweep(var=myVar, ...)
\end{verbatim}
        \end{quote}
        Even better than sweeping a fixed number of cycles is to do it 
        until the non-linear PDE has been solved satisfactorily:
        \begin{quote}
\begin{verbatim}
>>> while residual > desiredResidual:
...     residual = eq.sweep(var=myVar, ...)
\end{verbatim}
        \end{quote}
        Sweeps are used to achieve better solutions in
        Examples~\ref{examples:diffusion:mesh1D}, 
        \ref{examples:phase:simple}, 
        \ref{examples:phase:binary}, and \ref{examples:flow:stokesCavity}.

        \item[timesteps] This outermost layer of repetition is of most
        practical interest to the user. Understanding the time
        evolution of a problem is frequently the goal of studying a
        particular set of PDEs. Moreover, even when only an
        equilibrium or steady-state solution is desired, it may not be
        possible to simply solve that directly, due to non-linear
        coupling between equations or to boundary conditions or
        initial conditions. Some types of PDEs have fundamental 
        limits to how large a timestep they can take before they 
        become either unstable or inaccurate.
        \begin{reSTadmonition}[Note]
        Stability and accuracy are distinctly different. An unstable 
        solution is often said to ``blow up'', with radically 
        different values from point to point, often diverging to 
        infinity. An inaccurate solution may look perfectly 
        reasonable, but will disagree significantly from an 
        analytical solution or from a numerical solution obtained by 
        taking either smaller or larger timesteps. 
        \end{reSTadmonition}
        For all of these reasons, you will frequently need to advance
        a problem in time and to choose an appropriate interval
        between solutions. This can be simple:
        \begin{quote}
\begin{verbatim}
>>> timeStep = 1.234e-5
>>> for step in range(steps):
...     eq.solve(var=myVar, dt=timeStep, ...)
\end{verbatim}
        \end{quote}
        or more elaborate:
        \begin{quote}
\begin{verbatim}
>>> timeStep = 1.234e-5
>>> elapsedTime = 0
>>> while elapsedTime < totalElapsedTime:
...     eq.solve(var=myVar, dt=timeStep, ...)
...     elapsedTime += timeStep
...     timeStep = SomeFunctionOfVariablesAndTime(myVar1, myVar2, elapedTime)
\end{verbatim}
        \end{quote}

        A majority of the examples in this manual illustrate time
        evolving behavior. Notably, boundary conditions are made a
        function of elapsed time in
        Example~\ref{examples:diffusion:mesh1D}. The timestep is
        chosen based on the expected interfacial velocity in
        Example~\ref{examples:phase:simple}. The timestep is
        gradually increased as the kinetics slow down in
        Example~\ref{sec:Examples:cahnHilliard:mesh2D}.
    
    \end{description}
    
    Finally, we can (and often do) combine all three layers of repetition:
    \begin{quote}
\begin{verbatim}
>>> myVar = CellVariable(..., hasOld=1)
    : 
    :
>>> mySolver = LinearPCGSolver(iterations=1234, tolerance=5e-6) 
    : 
    :
>>> while elapsedTime < totalElapsedTime:
...     myVar.updateOld()
...     while residual > desiredResidual:
...         residual = eq.sweep(var=myVar, dt=timeStep, ...)
...     elapsedTime += timeStep
\end{verbatim}
    \end{quote}

    \section{Why the distinction between \Class{CellVariable} and
    \Class{FaceVariable} coefficients?}  \FiPy{} solves field
    variables on the \Class{Cell} centers.  Transient and source terms
    describe the change in the value of a field at the \Class{Cell}
    center, and so they take a \Class{CellVariable} coefficient.
    Diffusion and convection terms involve fluxes \emph{between}
    \Class{Cell} centers, and are calculated on the \Class{Face}
    between two \Class{Cell}s, and so they take a \Class{FaceVariable}
    coefficient.
    
    
    \begin{reSTadmonition}[Note]
        If you supply a \Class{CellVariable} \verb+var+ when a
        \Class{FaceVariable} is expected, \FiPy{} will automatically
        substitute \verb+var.getArithmeticFaceValue()+.  This can have
        undesirable consequences, however. For one thing, the 
        arithmetic face average of a non-linear function is not the 
        same as the same non-linear function of the average argument, 
        \emph{e.g.}, for $f(x) = x^2$,
        \[ f(\frac{1+2}{2}) = \frac{9}{4} \neq 
        \frac{f(1) + f(2)}{2} = \frac{5}{2} \]
        This distinction is not generally important for smoothly
        varying functions, but can dramatically affect the solution
        when sharp changes are present.  Also, for many problems, such
        as a conserved concentration field that cannot be allowed to
        drop below zero, a harmonic average is more appropriate than
        an arithmetic average.
        
        If you experience problems (unstable or wrong results, or 
        excessively small timesteps), you may need to explicitly supply the 
        desired \Class{FaceVariable} rather than letting \FiPy{} 
        assume one.
    \end{reSTadmonition}

    \section{How do I represent boundary conditions?}  

    \subsection{What is a \Class{FixedValue} boundary condition?}

    This is simply a Dirichlet boundary condition by another name.
    
    \subsection{What does the \Class{FixedFlux} boundary condition actually represent?}

    In \FiPy{} a \Class{FixedFlux} boundary condition object represents the
    quantity $$ \Gamma \vec{n} \cdot \nabla \phi - \vec{n} \cdot \vec{u} \phi $$
    on a given boundary edge with $\vec{n}$ pointing out of the boundary. The
    quantity $\Gamma$ represents the diffusion coefficient and $\vec{u}$
    represents the convection coefficient for a general convection-diffusion
    equation of the type given in Eq.~\eqref{eqn:num:gen}. See
    Example~\ref{sec:Examples:convection:robin} for a usage case.

    \subsection{I can't get the \Class{FixedValue} or \Class{FixedFlux} boundary
      condition objects to work right. What do I do now?\label{FAQ-anyBoundaryCondition}}

    There have been a number of questions on the mailing list about boundary
    conditions and from the feedback it is clear that there are some problematic
    issues with the design and implementation of the boundary condition objects.
    We hope to rectify this in future releases. However, it is possible to
    specify almost any boundary condition by using a rank 1 \verb+FaceVariable+
    to represent the external flux value and apply the \verb+getDivergence+
    method to this object and then use it as as a source term in the given
    equation. The following code demonstrates how to implement this technique.
    First define the coefficients,
\begin{verbatim}
>>> convectionCoeff = FaceVariable(..., rank=1)
>>> diffusionCoeff = FaceVariable(...)
\end{verbatim}
    where the \verb+convectionCoeff+ and \verb+diffusionCoeff+ are defined over
    all the faces. We will define a third \Class{FaceVariable} to represent the
    boundary source term and then set the values of the coefficients to zero on
    the exterior faces.
\begin{verbatim}
>>> boundarySource = FaceVariable(..., rank=1)
>>> convectionCoeff.setValue(0, where=mesh.getExteriorFaces())
>>> diffusionCoeff.setValue(0, where=mesh.getExteriorFaces())
>>> boundarySource.setValue(vectorValues, where=mesh.getExteriorFaces())
\end{verbatim}
    The \verb+vectorValues+ quantity can be set to whatever value is required for
    the particular boundary condition. The variable \verb+boundarySource+ could
    be a variable that defines a relationship between other variables rather than
    a simple container object. To finish off, the \verb+boundarySource.getDivergence()+ object
    must be added to the regular equation
\begin{verbatim}
>>> eqn = TransientTerm() + ConvectionTerm(convectionSource) = \
...     DiffusionSource(diffusionCoeff) + boundarySource.getDivergnces()
\end{verbatim}
    No other boundary conditions need to be applied. It may be necessary to reset
    or update the values of \verb+boundarySource+, \verb+diffusionCoeff+ and
    \verb+convectionCoeff+ at each sweep if they are not automatically updated or
    if the exterior values need to be reset to zero. For complex boundary
    conditions, it is often easier to implement the technique described here
    rather than trying to get the \Class{FixedValue} and \Class{FixedFlux}
    boundary conditions to work correctly.

    \subsection{How do I apply an outlet or inlet boundary
      condition?\label{FAQ-inletOutletBoundaryCondition}}

    There is no good way to do this with the standard boundary conditions in
    \FiPy{} and thus one needs to use the method suggested above,
    see~\ref{FAQ-anyBoundaryCondition} ``\titleref{FAQ-anyBoundaryCondition}''.
    Currently, boundary conditions for the \Class{ConvectionTerm} assume a
    \Class{FixedFlux} boundary condition with a \verb+value+ of 0. This is in
    fact not the most intuitive default boundary condition, a natural outlet or
    inlet boundary condition would in fact be more sensible. In order to apply an
    inlet/outlet boundary condition one needs a separate exterior convection
    coefficient (velocity vector) to hold the boundary values,
\begin{verbatim}
>>> convectionCoeff = FaceVaravble(..., rank=1)
>>> exteriorCoeff = FaceVariable(..., value=0, rank=1)
\end{verbatim}
    The \verb+exteriorCoeff+ can now be given non-zero values on
    \verb+inletOutletFaces+ and the \verb+convectionCoeff+ can be set to zero on
    these faces.
\begin{verbatim}
>>> exteriorCoeff.setValue(convectionCoeff, where=inletOutletFaces)
>>> convectionCoeff.setValue(0, where=inletOutletFaces)
\end{verbatim}
    where the \verb+inletOutletFaces+ object are the faces over which the
    inlet/outlet boundary condition applies. The divergence of the
    \verb+exteriorCoeff+ is then included in the equations with an
    \Class{ImplicitSourceTerm}. This allows an implicit formulation for outlet
    boundary conditions and an explicit formulation for inlet boundary
    conditions, consistent with an upwind convection scheme.
\begin{verbatim}
>>> eqn = TransientTerm() + ConvectionTerm(convectionCoeff) + \
...     ImplicitSourceTerm(exteriorCoeff.getDivergence()) == DiffusionTerm(diffusionCoeff)
\end{verbatim}
    As in the previous section, the coefficient values may need updating on the
    exterior faces between sweeps. See
    Example~\ref{sec:Examples:convection:source}
    ``\titleref{sec:Examples:convection:source}'' for an example of this usage.

    \subsection{How do I apply a fixed gradient?}

    In general, it is not currently possible to apply a fixed gradient or Von
    Neumann type boundary condition explicitly. Of course, it is often possible
    to use \Class{FixedValue} or \Class{FixedFlux} boundary conditions to mimic a
    fixed gradient condition. In the case when there is no convection, one can
    simply use a \Class{FixedFlux} condition and divide through by the diffusion
    coefficient to create the boundary condition,
\begin{verbatim}
FixedFlux(value=gradient / diffusionCoeff, faces=myFaces)
\end{verbatim}
    where \verb+gradient+ is the value of the boundary gradient and
    \verb+myFaces+ are the faces over which the boundary condition applies.  If
    the equation contains a \Class{ConvectionTerm} and the boundary condition has
    a zero gradient then one would use a \Class{FixedValue} boundary condition of
    the form
\begin{verbatim}
FixedValue(value=phi.getFaceValue(), faces=myFaces)
\end{verbatim}
    This is not an ''implicit'' boundary condition so would in general require
    sweeps to reach convergence. See Example~\ref{sec:Examples:convection:source}
    ``\titleref{sec:Examples:convection:source}'' for an example of this usage.
    In the case of a non-zero gradient one would need to employ the techniques in
    both~\ref{FAQ-anyBoundaryCondition} ``\titleref{FAQ-anyBoundaryCondition}''
    and~\ref{FAQ-inletOutletBoundaryCondition}
    ``\titleref{FAQ-inletOutletBoundaryCondition}'' without using either a
    \Class{FixedValue} or a \Class{FixedFlux} object.

    \subsection{How do I apply spatially varying boundary conditions?}

    The use of spatial varying boundary conditions is best demonstrated with an
    example. Given a 2D equation in the domain $0 < x < 1$ and $0 < y < 1$ with
    boundary conditions,
    \begin{eqnarray}
      \phi =& xy \; & \text{on $x>1/2$ and $y>1/2$} \\
      \vec{n} \cdot \vec{F} =& 0 \;& \text{elsewhere}
    \end{eqnarray}
    where $\vec{F}$ represents the flux. The boundary conditions in \FiPy{} can
    be written with the following code,
\begin{verbatim}
>>> x, y = mesh.getFaceCenters()
>>> mask =  ((x < 0.5) | (y < 0.5))
>>> BCs = [FixedFlux(value=0, faces=mesh.getExteriorFaces() & mask),
...        FixedValue(value=x * y, faces=mesh.getExteriorFaces() & ~mask)]
\end{verbatim}
    The \verb+BCs+ list can then be passed to the equation's \verb+solve+ method
    when its called,
\begin{verbatim}
>>> eqn.solve(..., boundaryConditions=BCs)
\end{verbatim}
    Further demonstrations of spatially varying boundary condition can be found
    in Examples~\ref{sec:Examples:diffusion:mesh20x20}
    ``\titleref{sec:Examples:diffusion:mesh20x20}''
    and~\ref{sec:Examples:diffusion:circle}
    ``\titleref{sec:Examples:diffusion:circle}''

%    http://thread.gmane.org/gmane.comp.python.fipy/726
%    http://thread.gmane.org/gmane.comp.python.fipy/846

%    \subsection{Fourth order boundary conditions}

%    http://thread.gmane.org/gmane.comp.python.fipy/923

%    \subsection{Periodic boundary conditions}

%    http://thread.gmane.org/gmane.comp.python.fipy/135

%    \subsection{Time dependent boundary conditions}

%    http://thread.gmane.org/gmane.comp.python.fipy/2

%    \subsection{Internal boundary conditions}

    \section{What does this error message mean?}\hspace*{\fill}
    
        \begin{description}
            
            \item[``\texttt{ValueError: frames are not aligned}'']
            
            This error most likely means that you have provided a
            \Class{CellVariable} when \FiPy{} was expecting a
            \Class{FaceVariable} (or vice versa).

            \item[``\texttt{MA.MA.MAError: Cannot automatically
            convert masked array to Numeric because data is masked in one or
            more locations.}'']
            
            This not-so-helpful error message could mean a number of things,
            but the most likely explanation is that the solution has become
            unstable and is diverging to $\pm\infty$.  This can be caused by
            taking too large a timestep or by using explicit terms instead of
            implicit ones.
            
            \item[``\texttt{repairing catalog by removing key}'']
            
            This message (not really an error, but may cause test 
            failures) can result when using the \SciPy{} \weave{} 
            package via the \verb+--inline+ flag. It is due to a bug
            in \SciPy{} that has been patched in their source 
            repository: \url{http://www.scipy.org/mailinglists/mailman?fn=scipy-dev/2005-June/003010.html}.
            
            \item[``\texttt{numerix Numeric 23.6}'']
            
            This is neither an error nor a warning. It's just a sloppy 
            message left in \SciPy{}:
            \url{http://thread.gmane.org/gmane.comp.python.scientific.user/4349}.
            
        \end{description}
        
    \section{How do I change \FiPy{}'s default behavior?}
        \label{FAQ-FlagsAndEnvironmentVariables}
        \FiPy{} tries to make reasonable choices, based on what 
        packages it finds installed, but there may be times that you 
        wish to override these behaviors. 
        \subsection{Command-line Flags}
        You can add any of the following flags after the name of a 
        script you call from the command line
        \begin{description}
            \item[\texttt{--inline}] Causes many mathematical
            operations to be performed in C, rather than Python, for
            improved performance. Requires the \SciPy{} \weave{}
            package. 

            \item[\texttt{--Pysparse}] Forces the use of the 
            \Trilinos{} solvers. This flag takes precedence over the 
            \texttt{FIPY\_SOLVERS} environment variable.

            \item[\texttt{--Trilinos}] Forces the use of the 
            \Trilinos{} solvers. This flag takes precedence over the 
            \texttt{FIPY\_SOLVERS} environment variable.
        \end{description}
        
        \subsection{Environment Variables}
        You can set any of the following environment variables in the 
        manner appropriate for your shell. If you are not running in 
        a shell (\emph{e.g.}, you are invoking \FiPy{} scripts from within IPython or 
        IDLE), you can set these variables via the 
        \texttt{os.environ} dictionary, but you must do so before 
        importing anything from the \texttt{fipy} package.
        \begin{description}
            \item[\texttt{FIPY\_DISPLAY\_MATRIX}] If present, causes
            the graphical display of the solution matrix of each
            equation at each call of \texttt{solve()} or
            \texttt{sweep()}. If set to ``\texttt{terms}'', causes the
            display of the matrix for each \Class{Term} that composes
            the equation. Requires the \Matplotlib{} package.

            \item[\texttt{FIPY\_INLINE}] If present, causes many
            mathematical operations to be performed in C, rather than
            Python. Requires the \SciPy{} \weave{} package.
        
            \item[\texttt{FIPY\_INLINE\_COMMENT}] If present, causes
            the addition of a comment showing the Python context that
            produced a particular piece of \SciPy{} \weave{} C code.
            Useful for debugging.
        
            \item[\texttt{FIPY\_SOLVERS}] Forces the use of the
            specified suite of linear solvers. Valid
            (case-insensitive) choices are ``\texttt{PySparse}'' and
            ``\texttt{Trilinos}''.
            
            \item[\texttt{FIPY\_VIEWER}] Forces the use of the 
            specified viewer. Valid values are any 
            ``\texttt{\textit{<viewer>}}''
            from the \texttt{\EpydocDottedName{fipy.viewers.\textit{<viewer>}Viewer}} 
            modules. The special value of ``\texttt{dummy}'' will 
            allow the script to run without displaying anything.
        \end{description}


    \section{What if my question isn't answered here?}  
        
        Please post your question to the
        \href{http://www.ctcms.nist.gov/fipy/mail.html}{mailing list}
        \cite{FiPyMailingList} or
        \href{http://sourceforge.net/tracker/?group_id=118428}{file a
        Tracker request} \cite{FiPyBugTracker}.
