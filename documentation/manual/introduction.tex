\section{Aims}

The goal of the \FiPy{} framework is to provide to the scientific
community a highly customizable, open source code for modeling
problems involving coupled sets of PDEs.  \FiPy{} allows users to
select and customize modules from within the framework.  Those modules
can then be combined with an extremely powerful, high-level scripting
language, allowing the user full control over the solution algorithm.
This `top down' method of computer programming allows significant code
reuse while accounting for the unique vagaries of each problem.

The framework is known as \FiPy{} and is developed at the top level in
the \Python{} programming language.  \Python{} enables the integration
of low-level, high-performance languages such as C and FORTRAN
allowing for efficient optimization.  \Python{} also has a large
repository of free numerical and scientific software that can be
integrated into the \FiPy{} framework.  At \NIST{}, there is a
significant ongoing effort to maximize the efficiency of \FiPy{} with
the use of third party software and the judicious use of the C
programming language embedded in standard core modules.

The end goal of \FiPy{} is to provide a realistic open source choice
for solving coupled sets of equations. Once an efficient customizable
framework is developed, the end goal will only be achieved with proper
support for the community of users. Many previous scientific computing
projects, although valuable tools, are not adopted by the end users
due to inadequate distribution tools and lack of support. Adequate
support consists of clear documentation, efficient distribution
methods, a code repository, regular code updates (bug fixes) and a
test infrastructure. We aim to address all of these issues.

The aims mentioned above can be summarized as follows:

\begin{itemize}
    \item Develop core test piece models for various materials science problems.

    \item Develop a highly efficient and customizable code.

    \item Support the distribution of code to the end users.
\end{itemize}

\section{Background}

The equations that model the evolution of physical, chemical and
biological systems often have a remarkably universal form.  Indeed,
partial differential equations (PDEs) have proven necessary to model
complex physical systems and processes that involve variations in both
space and time.  In general, given a variable of interest \( \phi \)
such as species concentration, pH or temperature, there exists an
evolution equation of the form
\begin{equation}
  \frac{\partial \phi}{\partial t} = H(\phi, \lambda_i)
  \label{eqn:general-equation}
\end{equation}
where \( H \) is a function of \(\phi\), other state variables
\(\lambda_i\), and higher order derivatives of all of these variables.
Examples of such systems are wide ranging, but include problems that
exhibit a combination of diffusing and reacting species, as well as
such diverse problems as determination of the electric potential in
heart tissue, of fluid flow, stress evolution, and even the
Schr\"odinger equation.

The initial implementation of \FiPy{} has been developed to address
model problems in materials science such as poly-crystals, dendritic
growth and electrochemical deposition. These applications all contain
various combinations of PDEs with differing forms in conjunction with
other unusual physics (over varying length scales) and unique solution
procedures. The philosophy of \FiPy{} is to enable unique
customization while providing a library of efficient modules for
common objects and data types.

\section{Design}

The core methods in the \FiPy{} design are outlined in the following
sections.

\subsection{Object Oriented Approach}

\FiPy{} is programmed in an object-oriented manner.  The benefit of
object oriented programming mainly lies in encapsulation and
inheritance.  Encapsulation allows parts of the code to be separated
into clearly defined independent modules that can be re-applied or
extended in new ways.  Inheritance allows code to be reused and new
capabilities to be added without altering the original code.

\subsection{Test Based Development}

\FiPy{} has been developed with a large number of test cases.  These
test cases operate on two levels.  The lower level tests operate on
the core modules at the individual method level.  The aim is that
every method within the core installation has a test case.  The high
level test cases operate in conjunction with example test piece
solutions and test global solution algorithms and the interaction of
various modules.  Thus at any stage in code development the test cases
can be executed and errors can be identified.

A test base is essential for the adoption of the code by new users and
developers. It provides reassurance that any code breakages will be
clearly demonstrated with a broken test case. A test base also aids
dissemination of the code by providing simple examples and knowledge
of whether the code is working on a particular computer environment.

\subsection{Documentation}

\FiPy{} has been developed with a continuously updated manual. The
manual contains introductory material, installation procedures and
explanation of numerical algorithms. The manual also contains an
automated description of each module and method. The automated
description is derived from comments in the source code. Thus the
manual will stay current as the code develops and encourage developers
to comment the code. The same automated method is used to build
descriptions of core examples making it easy for a prospective user to
understand and start using the code.

\subsection{Numerical Approach}

The solution algorithms given in the \FiPy{} examples involve combining
sets of PDEs while tracking an interface where the parameters of the
problem change rapidly. The Phase Field Method (PFM) and the Level Set
Method (LSM) are specialized techniques to handle the solution of
PDEs in conjunction with a deforming interface. The combination of
these methods within one code is novel and useful for academic as well
as practical comparison of both methods. Both methods are not new but
are still undergoing constant development.

\FiPy{} uses the well-known Finite Volume Method (FVM) to reduce the
model equations to a form tractable to linear solvers.

\subsection{Distribution}

Clear distribution techniques and easy installation are required for
prospective users to begin using the code. Two prospective methods are
planned for code distribution. The first method is simply creating
stable archive releases that users can unpack. The second method is to
create a code repository where users can update to the latest unstable
version of the code. This is useful to allow users access to the
latest bug fixes. Also having a central code repository allows more
developers to join the main project or select parts of the project.

\subsection{Open Source}

In recent years there has been a movement to release software under
open source and associated unrestrictied licenses, especially within
the scientific community.  These licensing terms allow users to
develop their own applications with complete access to the source code
and then either contribute back to the main source repository or
freely distribute their new adapted version.  As a product of the
National Institute of Standards and Technology, the \FiPy{} framework
is placed in the public domain as a matter of U. S. Federal law.

\subsection{High-Level Scripting Language}

A rather common scenario in the development of scientific codes is
that the first draft hard-codes all of the problem parameters.  After
a few (hundred) iterations of recompiling and relinking the
application to explore changes to the parameters, code is added to
read an input file containing a list of numbers.  Eventually, the
point is reached where it is impossible to remember which parameter
comes in which order or what physical units are required, so code is
added to, for example, interpret a line beginning with `\verb|#|' as a
comment.  At this point, the programmer has begun developing a
scripting language without even knowing it.  Unfortunately for them,
very few scientists have actually studied computer science or actually
know anything about the design and implementation of script
interpreters.  Even if they have the expertise, the time spent
developing such a language interpreter is time not spent actually
doing research.

In contrast, a number of very powerful scripting languages, such as
Tcl, Java, Python, Ruby, and even the venerable BASIC, have been
developed that have open source interpreters that can be embedded
directly in an application, giving scientific codes immediate access
to a high-level scripting language designed by someone who actually
knew what they were doing.

We have chosen to go a step further and not just embed a full-fledged 
scripting language in the \FiPy{} framework, but instead to design the
framework from the ground up in a scripting language.

Scientific codes, when programmed exclusively in C or FORTRAN, are
often hard to readapt to new application areas mainly due to the
inability to allow developers access at various levels of the code.
In general, such codes use a distinctive scripting language written
for the code at hand allowing users to vary parameter values and
switch between different internal solution algorithms.  Such exclusive
scripting languages can often be difficult to write and must be an
integral part of the design of the numerical code and cannot easily
account for the various ways a prospective user may wish to use the
code.

Scripting languages are seen as distinctive from compiled
lower level languages such as C or FORTRAN. Such lower level languages
are commonly used for numerical codes due to their increased
efficiency over scripting languages.  

Thus \FiPy{}, rather than taking the approach of writing the fast
numerical code first and then dealing with the issue of user
interaction, initially implements most modules in the \Python{}
scripting language and only translates to C those parts of the code
that prove inefficient. This leads to most top-level structures being
written in \Python{} allowing easy to understand implementation and
modification. 

\subsection{\Python{} Programming Language}

Although a number of scripting languages offer a number, if not all,
of the features above, we have selected \Python{} for the
implementation of \FiPy{}.  \Python{} combines remarkable power with
very clear syntax.  It is freely usable and distributable, even for
commercial use.  \Python{} is an example of an interpreted scripting
language.  

This makes \Python{} an unusual
choice for the bases of a numerical framework.

The choice of \Python{} is in part due to the easy integration of C
either as separate modules or encapsulated in \Python{} (\weave{})
functions as well as the ability to directly translate from \Python{}
to C (\blitz{}, \PyRex{}).  This low-level integration has resulted in
a number of freely available efficient numerical modules (\SciPy{},
\Numeric{}) for \Python{} some of which are utilized in the \FiPy{}
framework.

\Python{} has modules (\doctest{}, \unittest{}) that automate the
testing procedure.


\section{Outstanding Issues}

\subsection{Efficiency}

\subsection{Memory Usage}