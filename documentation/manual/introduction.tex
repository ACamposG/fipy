The goal of \FiPy{} is to provide a highly customizable, open source
code for modeling problems involving coupled sets of PDEs.  \FiPy{}
allows users to select and customize modules from within the
framework.  The initial implementation of \FiPy{} has been developed
to address model problems in materials science such as poly-crystals,
dendritic growth and electrochemical deposition.  These applications
all contain various combinations of PDEs with differing forms in
conjunction with other unusual physics (over varying length scales)
and unique solution procedures.  The philosophy of \FiPy{} is to
enable customization while providing a library of efficient modules
for common objects and data types.

\section{Design}

\subsection{Numerical Approach}

The solution algorithms given in the \FiPy{} examples involve combining
sets of PDEs while tracking an interface where the parameters of the
problem change rapidly. The phase field method and the level set
method are specialized techniques to handle the solution of
PDEs in conjunction with a deforming interface. \FiPy{} contains
several examples of both methods.

\FiPy{} uses the well-known Finite Volume Method (FVM) to reduce the
model equations to a form tractable to linear solvers.

\subsection{Object Oriented Structure}

\FiPy{} is programmed in an object-oriented manner.  The benefit of
object oriented programming mainly lies in encapsulation and
inheritance.  Encapsulation refers to the tight integration between
certain pieces of data and methods that act on that data.
Encapsulation allows parts of the code to be separated into clearly
defined independent modules that can be re-applied or extended in new
ways.  Inheritance allows code to be reused, overridden, and new
capabilities to be added without altering the original code. An object
is treated by its users as an abstraction; the details of its
implementation and behavior are internal.

\subsection{Test Based Development}

\FiPy{} has been developed with a large number of test cases.  These
test cases are in two categories.  The lower level tests operate on
the core modules at the individual method level.  The aim is that
every method within the core installation has a test case.  The high
level test cases operate in conjunction with example test piece
solutions and test global solution algorithms and the interaction of
various modules.  Thus, at any stage in code development, the test cases
can be executed and errors can be identified.

A comprehensive test base provides reassurance that any code breakages
will be clearly demonstrated with a broken test case.  A test base
also aids dissemination of the code by providing simple examples and
knowledge of whether the code is working on a particular computer
environment.

\subsection{Open Source}

In recent years, there has been a movement to release software under
open source and associated unrestrictied licenses, especially within
the scientific community.  These licensing terms allow users to
develop their own applications with complete access to the source code
and then either contribute back to the main source repository or
freely distribute their new adapted version.  

As a product of the National Institute of Standards and Technology,
the \FiPy{} framework is placed in the public domain as a matter of U.
S. Federal law. Furthermore, \FiPy{} is built upon existing open source 
tools. Others are free to use \FiPy{} as they see fit and we welcome
contributions to make \FiPy{} better.

\subsection{High-Level Scripting Language}

A rather common scenario in the development of scientific codes is
that the first draft hard-codes all of the problem parameters.  After
a few (hundred) iterations of recompiling and relinking the
application to explore changes to the parameters, code is added to
read an input file containing a list of numbers.  Eventually, the
point is reached where it is impossible to remember which parameter
comes in which order or what physical units are required, so code is
added to, for example, interpret a line beginning with `\verb|#|' as a
comment.  At this point, the scientist has begun developing a
scripting language without even knowing it.  Unfortunately for them,
very few scientists have actually studied computer science or actually
know anything about the design and implementation of script
interpreters.  Even if they have the expertise, the time spent
developing such a language interpreter is time not spent actually
doing research.

In contrast, a number of very powerful scripting languages, such as
Tcl, Java, Python, Ruby, and even the venerable BASIC, have open
source interpreters that can be embedded directly in an application,
giving scientific codes immediate access to a high-level scripting
language designed by someone who actually knew what they were doing.

We have chosen to go a step further and not just embed a full-fledged 
scripting language in the \FiPy{} framework, but instead to design the
framework from the ground up in a scripting language.

Thus \FiPy{}, rather than taking the approach of writing the fast
numerical code first and then dealing with the issue of user
interaction, initially implements most modules in the \Python{}
scripting language and only translates to C those parts of the code
that prove inefficient. This leads to most top-level structures being
written in \Python{} allowing easy to understand implementation and
modification. 

\subsection{\Python{} Programming Language}

Acknowledging that several scripting languages offer a number, if not
all, of the features described above, we have selected \Python{} for
the implementation of \FiPy{}.  Python is:

\begin{itemize}
    
    \item an interpreted language that combines remarkable power with very clear
    syntax.
    
    \item freely usable and distributable, even for commercial use.
    
    \item fully object oriented.
    
    \item distributed with powerful automated testing tools (\doctest{}, \unittest{}).

    \item actively used and extended by other scientists and
    mathemeticians (\SciPy{}, \Numeric{}, \PySparse{}).
    
    \item easily integrated with low-level languages such as C
    (\weave{}, \blitz{}, \PyRex{}).
    
\end{itemize}

\section{Implementation}

The \Python{} classes that make up \FiPy{} are described in detail in
the \href{file:reference.pdf}{\textit{\FiPy{} Programmer's Reference}},
but we give a brief overview here.  \FiPy{} is based around three
fundamental \Python{} classes: \Class{Variable}, \Class{Mesh}, and
\Class{Equation}.  
\begin{description}
    \item[\Class{Mesh}] Using the terminology of
    Chapter~\ref{chap:Numerics}, the \Class{Mesh} represents the
    domain of interest.  \FiPy{} contains many different specific mesh
    classes to describe different geometries.

    \item[\Class{Variable}] A particular type of \Class{Variable},
    called a \Class{CellVariable}, represents \( \phi \) at the
    centers of the \Class{Cell}s of the \Class{Mesh}.  A
    \Class{CellVariable} describes the values of the field \( \phi \),
    but it is not concerned with their geometry; that role is taken by
    the \Class{Mesh}.

    An important property of \Class{Variable} objects is that they can
    describe dependency relationships, such that:
    \begin{verbatim}
	>>> a = Variable(value = 3)
	>>> b = a * 4
    \end{verbatim}
    does not assign the value \verb|12| to \verb|b|, but rather it assigns
    a multiplication operator object to \verb|b|, which depends on the
    \Class{Variable} object \verb|a|:
    \begin{verbatim}
	>>> b
	(Variable(value = 3) * 4)
	>>> a.setValue(5)
	>>> b
	(Variable(value = 5) * 4)
    \end{verbatim}
    The numerical value of the \Class{Variable} is not calculated until it
    is needed (a process known as ``lazy evaluation''):
    \begin{verbatim}
	>>> print b
	20
    \end{verbatim}

    \item[\Class{Equation}] An \Class{Equation} object represents
    Equation~\eqref{eqn:general-equation}. 
\end{description}

Beyond these three fundamental classes, \FiPy{} is composed of a
number of related classes.  As shown conceptually in
Equation~\eqref{eqn:num:gen}, an \Class{Equation} is composed of
multiple \Class{Term} objects.  \Class{BoundaryCondition} objects are
used to describe the conditions on the boundaries of the \Class{Mesh}.
The relationships between these classes are shown in
Figure~\ref{fig:objects}.

At this point, it may be useful to examine some of the example
problems in Part~\ref{part:Examples}.  More classes are introduced in
the examples, along with illustrations of their instantiation and use.


