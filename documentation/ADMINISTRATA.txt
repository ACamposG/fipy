=============
SVN practices
=============

Refer to SVN.txt for the current tagging conventions.

--------
Branches
--------

The following needs to be updated as we become more experienced with SVN.

Break off for radical refactoring. We will use the following method to
preserve the tags/ and branches/ policy, though not strictly necessary
with SVN::
    
    $ BRANCH=branch-refactoring_etc
    $ FIPYROOT=svn+ssh://username@matdl-osi.org/usr/local/svn-fipy-repos/
    $ svn copy $FIPYROOT/trunk $FIPYROOT/tags/root-$BRANCH -m "creating tag for $BRANCH"
    $ svn copy $FIPYROOT/trunk $FIPYROOT/branches/$BRANCH -m "creating branch for $BRANCH"
    $ cd outside/of/SVN/working/copy
    $ svn co $FIPYROOT/branches/$BRANCH

Edit and add to branch::

    $ cd where/ever//$BRANCH
    $ emacs ...
    $ svn ci -m "refactoring_stage_A"
    $ svn copy $FIPYROOT/$BRANCH $FIPYROOT/tags/refactoring_stage_A -m "refactoring_stage_A"
    $ emacs ...
    $ svn ci -m "refactoring_stage_B"
    $ svn copy $FIPYROOT/$BRANCH $FIPYROOT/tags/refactoring_stage_A -m "refactoring_stage_A"

Merge developments from trunk::

    $ svn copy $FIPYROOT/trunk $FIPYROOT/tags/somePointOnTrunk -m "tag for $BRANCH merge"
    $ svn diff $FIPYROOT/tags/root-$BRANCH $FIPYROOT/tags/somePointOnTrunk
    $ svn merge $FIPYROOT/tags/root-$BRANCH $FIPYROOT/tags/somePointOnTrunk $FIPYROOT/branches/$BRANCH
    $ cd where/ever/$BRANCH
    $ python setup.py test
    $ svn ci -m "merged main trunk"
    $ svn copy $FIPYROOT/branches/$BRANCH $FIPYROOT/tags/merge-somePointOnTrunk_to_$BRANCH -m "tagging merge from trunk"

Refactoring complete::

    $ svn copy $FIPYROOT/branches/$BRANCH $FIPYROOT/tags/end-$BRANCH -m "finished with branch"
    $ svn diff $FIPYROOT/tags/root-$BRANCH $FIPYROOT/branches/$BRANCH
    $ svn merge $FIPYROOT/tags/root-$BRANCH $FIPYROOT/branches/$BRANCH $FIPYROOT/trunk
    $ cd where/ever/trunk
    $ python setup.py test
    $ svn ci -m "merged $BRANCH"
    $ svn copy $FIPYROOT/trunk $FIPYROOT/tags/$BRANCH-merged -m "merged $BRANCH"	

**Now cease all work on branch-refactoring_etc**

Optionally 

    $ cd where/ever/$BRANCH
    $ echo "$BRANCH merged back to trunk: `date`" > "THIS BRANCH IS FINISHED"
    $ svn add "THIS BRANCH IS FINISHED"
    $ svn ci -m "" "THIS BRANCH IS FINISHED"

--------
Versions
--------

At point of version release x.y, *on main trunk*::

    $ svn copy $FIPYROOT/trunk $FIPYROOT/tags/version-x_y -m "tagging version x.y"
    $ svn copy $FIPYROOT/tags/version-x_y $FIPYROOT/tags/STABLE -m "tagging STABLE"
    $ svn copy $FIPYROOT/tags/version-x_y $FIPYROOT/tags/CURRENT -m "tagging CURRENT"	

---------
Bug fixes
---------

At the point some fix is made to an old version n.m, *on main trunk*::

    $ svn copy $FIPYROOT/tags/version-n_m  $FIPYROOT/branches/branch-version-n_m -m "making branck for version n.m"
    $ cd outside/of/SVN/working/copy
    $ svn co $FIPYROOT/branches/branch-version-n_m

Fix the code::

    $ cd where/ever/branch-version-n_m
    $ svn ci -m "fix n.m.q"
    $ svn copy $FIPYROOT/branches/branch-version-n_m $FIPYROOT/tags/version-n_m_q

Possibly::

    $ svn copy $FIPYROOT/tags/version-n_m_q $FIPYROOT/tags/CURRENT -m "tagging CURRENT" 
    $ svn copy $FIPYROOT/tags/version-n_m_q $FIPYROOT/tags/STABLE -m "tagging STABLE" 

Now merge n.m.q changes back to main trunk::

    $ svn diff $FIPYROOT/tags/version-n_m $FIPYROOT/branches/branch-version-n_m
    $ svn merge $FIPYROOT/tags/version-n_m $FIPYROOT/branches/branch-version-n_m $FIPYROOT/trunk
    $ cd where/ever/trunk
    $ svn ci -m "merged version n.m.q"    
    $ svn copy $FIPYROOT/trunk $FIPYROOT/tags/merge-branch-version-n_m_q -m "tagging version n.m.q merge"

Make new fix q+1 to n.m::

    $ cd where/ever/branch-version-n_m 
    
Fix the code::

    $ svn ci -m "fix version n.m.q+1"
    $ svn copy $FIPYROOT/branches/branch-version-n_m $FIPYROOT/tags/version-n_m_q+1

Again, merge n.m.q+1 changes back to main trunk::

    $ svn diff $FIPYROOT/tags/version-n_m_q $FIPYROOT/branches/branch-version-n_m_q+1
    $ svn merge $FIPYROOT/tags/version-n_m_q $FIPYROOT/branches/branch-version-n_m_q+1 $FIPYROOT/trunk
    $ cd where/ever/trunk
    $ svn ci -m "merged version n.m.q+1"    
    $ svn copy $FIPYROOT/trunk $FIPYROOT/tags/merge-branch-version-n_m_q+1 -m "tagging version n.m.q+1 merge"

================
Making a Release
================

Change the version number in fipy/__init__.py

Check items in TODOLIST.txt

Tag the repository as appropriate (see `SVN practices`_ above).

Check out a clean copy of the desired release::

    $ svn co $FIPYROOT/trunk CLEAN
    $ cd CLEAN

Run the test suite!:

    $ python setup.py test --no-cache
    $ python setup.py test --inline --no-cache
    $ python setup.py test --cache
    $ python setup.py test --inline --cache

.. attention:: If tests don't pass, make sure the release notes reflect 
   that fact!

Build the documentation and the web pages::

    $ python setup.py build_docs --manual --latex --webpage

Build the compressed distribution::

    $ rm MANIFEST
    $ python setup.py sdist

Build a windows executable installer::

    $ rm MANIFEST
    $ python setup.py bdist --formats=wininst

Combine the windows installer and examples into one tar ball.

    $ rm MANIFEST
    $ python setup.py sdist --template=MANIFEST-WINDOWS.in --dist-dir=dist-windows --no-defaults
    $ set FIPY_VERSION=XXX
    $ mv dist-windows/FiPy-${FIPY_VERSION}.tar.gz dist/FiPy-${FIPY_VERSION}.win32.tar.gz

Upload to the CTCMS website::

    $ python setup.py build_docs --upload

.. warning:: Some versions of ``rsync`` on Mac OS X have caused problems
   when they try to upload erroneous ``\rsrc`` directories. Version 2.6.2
   does not have this problem.

`Upload the release to SourceForge`_.  You can use, e.g.,::

    cvs2cl.pl --branches --tagdates --utc --usermap documentation/UFILE.txt --delta version-1_0a1:HEAD --hide-filenames

to build the ChangeLog.

Make an announcement to `fipy@nist.gov`_


.. Upload the release to SourceForge: https://sourceforge.net/project/admin/qrs.php?package_id=&group_id=118428
.. fipy@nist.gov: mailto:fipy@nist.gov

==========================================
Making a Windows Distribution for Pysparse
==========================================

Make sure of the following:

   - mingw is installed
   - libpython.a is in c:\pythonXX\libs
   - libblas.a is in c:\mingw\lib
   - liblapack.a is in c:\mingw\lib
   - Numeric is installed

If the above is not satisfied implement the Pysparse INSTALL instructions.

Set the PATH to use MINGW's tools.

   set PATH=C:\mingw\bin

Build the distribution.

   C:\pythonXX\python setup.py build --compiler=mingw32 bdist --format=wininst

.. include:: utils/include.txt

.. |FiPy| replace:: |htmlFiPy| |latexFiPy|

===============================
Converting a CVS Project to SVN
===============================

Obtain cvs2svn_

.. _cvs2svn: http://cvs2svn.tigris.org/

.. note::

   `cvs2svn-1.3.0/www/faq.html` covers this, but if you follow its directions 
   exactly, you will get the rather ridiculous::

       REPOSITORY
          |
          |---> ${PROJECT}
          |         |
          |         |---> trunk
          |         |        |
          |         |        |---> ${PROJECT}
          |         |
          |         |---> branches
          |         |        |
          |         |        |---> BRANCH1
          |         |        |       |
          |         |        |       |---> ${PROJECT}
          |         |        |
          |         |        |---> BRANCH2
          |         |                |
          |         |                |---> ${PROJECT}
          |         |
          |         |---> tags
          |                  |
          |                  |---> TAG1
          |                  |       |
          |                  |       |---> ${PROJECT}
          |                  |
          |                  |---> TAG2
          |                          |
          |                          |---> ${PROJECT}
          |
          |---> SOME_OTHER_PROJECT1
          |
          |---> SOME_OTHER_PROJECT2

   instead of the more desirable::

       REPOSITORY
          |
          |---> ${PROJECT}
          |         |
          |         |---> trunk
          |         |
          |         |---> branches
          |         |        |
          |         |        |---> BRANCH1
          |         |        |
          |         |        |---> BRANCH2
          |         |
          |         |---> tags
          |                  |
          |                  |---> TAG1
          |                  |
          |                  |---> TAG2
          |
          |---> SOME_OTHER_PROJECT1
          |
          |---> SOME_OTHER_PROJECT2


Make a copy of the portion of the CVS repository governing the project in 
question

    $ PROJECT=MyProjectInCVS
    $ mkdir cvs2svnSandbox
    $ cd cvs2svnSandbox
    $ cp -r /path/to/cvs/repository/${PROJECT} ${PROJECT}

Convert the CVS project repository copy into an SVN repository dump file

    $ mkdir ${PROJECT}/CVSROOT
    $ cvs2svn --dump-only ${PROJECT}

You should now have a file `cvs2svn-dump` in your working directory.

If necessary, create an SVN repository

    $ svnadmin create --fs-type fsfs /path/to/svn/repos

.. note:: An FSFS repository has fewer permissions problems than a Berkeley-DB 
   repository.

Make sure that the new repository has appropriate group permissions (this is
still a bit fuzzy for me)

    $ chgrp -R $GROUP /path/to/svn/repos
    $ chmod -R g+w /path/to/svn/repos

Add a stub for the new project

    $ svn mkdir file:///path/to/svn/repos/${PROJECT} -m "added ${PROJECT} directory"

Import the converted project repository into SVN

    $ svnadmin --parent-dir $PROJECT load /path/to/svn/repos < cvs2svn-dump

You can now test a checkout

    $ svn checkout svn+ssh://MACHINE.IP.ADDR/path/to/svn/repos/${PROJECT}/trunk SVNTEST

At this point, you can get rid of all of the conversion materials

    $ cd ..
    $ rm -rf cvs2svnSandbox
